;; Object semantic.cache
;; SEMANTICDB Tags save file
(semanticdb-project-database "semantic.cache"
  :file "semantic.cache"
  :tables (list 
   (semanticdb-table "bibtex.el"
    :file "bibtex.el"
    :pointmax 159687
    :major-mode 'emacs-lisp-mode
    :tokens '(("eval-when-compile" code nil [1488 1528]) ("bibtex-maintainer-address" variable nil "Dirk Herrmann <D.Herrmann@tu-bs.de>" ((const . t)) nil nil [1550 1626]) ("bibtex-maintainer-salutation" variable nil "Hallo Dirk," ((const . t)) nil nil [1650 1705]) ("defgroup" code nil [1749 1821]) ("defgroup" code nil [1823 1974]) ("bibtex-mode-hook" variable nil nil nil "List of functions to call on entry to BibTeX mode." nil [1976 2094]) ("bibtex-field-delimiters" variable nil (quote braces) ((user-visible . t)) "*Controls type of field delimiters used.
Set this to `braces' or `double-quotes' according to your personal
preferences.  This variable is buffer-local." nil [2096 2371]) ("make-variable-buffer-local" code nil [2372 2425]) ("bibtex-entry-delimiters" variable nil (quote braces) ((user-visible . t)) "*Controls type of entry delimiters used.
Set this to `braces' or `parentheses' according to your personal
preferences.  This variable is buffer-local." nil [2427 2698]) ("make-variable-buffer-local" code nil [2699 2752]) ("bibtex-include-OPTcrossref" variable nil (quote ("InProceedings" "InCollection")) ((user-visible . t)) "*All entries listed here will have an OPTcrossref field." nil [2754 2929]) ("bibtex-include-OPTkey" variable nil t ((user-visible . t)) "*If non-nil, all entries will have an OPTkey field.
If this is a string, it will be used as the initial field text.
If this is a function, it will be called to generate the initial field text." nil [2931 3334]) ("bibtex-user-optional-fields" variable nil (quote (("annote" "Personal annotation (ignored)"))) ((user-visible . t)) "*List of optional fields the user wants to have always present.
Entries should be of the same form as the OPTIONAL and
CROSSREF-OPTIONAL lists in `bibtex-entry-field-alist' (see documentation
of this variable for details)." nil [3336 3857]) ("bibtex-entry-format" variable nil (quote (opts-or-alts numerical-fields)) ((user-visible . t)) "*Controls type of formatting performed by `bibtex-clean-entry'.
It may be t, nil, or a list of symbols out of the following:
opts-or-alts        Delete empty optional and alternative fields and
                      remove OPT and ALT prefixes from used fields.
numerical-fields    Delete delimiters around numeral fields.
page-dashes         Change double dashes in page field to single dash
                      (for scribe compatibility).
inherit-booktitle   If entry contains a crossref field and booktitle
                      field is empty, it is set to the contents of the
                      title field of the crossreferenced entry.
                      Caution: this will work only if buffer is
                       correctly sorted.
realign             Realign entries, so that field texts and perhaps equal
                      signs (depending on the value of
                      `bibtex-align-at-equal-sign') begin in the same column.
last-comma          Add or delete comma on end of last field in entry,
                      according to value of `bibtex-comma-after-last-field'.
delimiters          Change delimiters according to variables
                      `bibtex-field-delimiters' and `bibtex-entry-delimiters'.
unify-case          Change case of entry and field names.

The value t means do all of the above formatting actions.
The value nil means do no formatting at all." nil [3859 5675]) ("bibtex-clean-entry-hook" variable nil nil ((user-visible . t)) "*List of functions to call when entry has been cleaned.
Functions are called with point inside the cleaned entry, and the buffer
narrowed to just the entry." nil [5677 5908]) ("bibtex-sort-ignore-string-entries" variable nil t ((user-visible . t)) "*If non-nil, BibTeX @String entries are not sort-significant.
That means they are ignored when determining ordering of the buffer
(e.g., sorting, locating alphabetical position for new entries, etc.).
This variable is buffer-local." nil [5910 6227]) ("make-variable-buffer-local" code nil [6228 6291]) ("bibtex-maintain-sorted-entries" variable nil nil ((user-visible . t)) "*If non-nil, BibTeX mode maintains all BibTeX entries in sorted order.
Setting this variable to nil will strip off some comfort (e.g., TAB
completion for reference keys in minibuffer, automatic detection of
duplicates) from BibTeX mode.  See also `bibtex-sort-ignore-string-entries'.
This variable is buffer-local." nil [6293 6692]) ("make-variable-buffer-local" code nil [6693 6753]) ("bibtex-field-kill-ring-max" variable nil 20 ((user-visible . t)) "*Max length of `bibtex-field-kill-ring' before discarding oldest elements." nil [6755 6909]) ("bibtex-entry-kill-ring-max" variable nil 20 ((user-visible . t)) "*Max length of `bibtex-entry-kill-ring' before discarding oldest elements." nil [6911 7065]) ("bibtex-parse-keys-timeout" variable nil 60 ((user-visible . t)) "*Specifies interval for parsing buffers.
All BibTeX buffers in Emacs are parsed if Emacs has been idle
`bibtex-parse-keys-timeout' seconds.  Only buffers which were modified
after last parsing and which are maintained in sorted order are parsed." nil [7067 7391]) ("bibtex-entry-field-alist" variable nil (quote (("Article" ((("author" "Author1 [and Author2 ...] [and others]") ("title" "Title of the article (BibTeX converts it to lowercase)") ("journal" "Name of the journal (use string, remove braces)") ("year" "Year of publication")) (("volume" "Volume of the journal") ("number" "Number of the journal (only allowed if entry contains volume)") ("pages" "Pages in the journal") ("month" "Month of the publication as a string (remove braces)") ("note" "Remarks to be put at the end of the \\bibitem"))) ((("author" "Author1 [and Author2 ...] [and others]") ("title" "Title of the article (BibTeX converts it to lowercase)")) (("pages" "Pages in the journal") ("journal" "Name of the journal (use string, remove braces)") ("year" "Year of publication") ("volume" "Volume of the journal") ("number" "Number of the journal") ("month" "Month of the publication as a string (remove braces)") ("note" "Remarks to be put at the end of the \\bibitem")))) ("Book" ((("author" "Author1 [and Author2 ...] [and others]" "" t) ("editor" "Editor1 [and Editor2 ...] [and others]" "" t) ("title" "Title of the book") ("publisher" "Publishing company") ("year" "Year of publication")) (("volume" "Volume of the book in the series") ("number" "Number of the book in a small series (overwritten by volume)") ("series" "Series in which the book appeared") ("address" "Address of the publisher") ("edition" "Edition of the book as a capitalized English word") ("month" "Month of the publication as a string (remove braces)") ("note" "Remarks to be put at the end of the \\bibitem"))) ((("author" "Author1 [and Author2 ...] [and others]" "" t) ("editor" "Editor1 [and Editor2 ...] [and others]" "" t) ("title" "Title of the book")) (("publisher" "Publishing company") ("year" "Year of publication") ("volume" "Volume of the book in the series") ("number" "Number of the book in a small series (overwritten by volume)") ("series" "Series in which the book appeared") ("address" "Address of the publisher") ("edition" "Edition of the book as a capitalized English word") ("month" "Month of the publication as a string (remove braces)") ("note" "Remarks to be put at the end of the \\bibitem")))) ("Booklet" ((("title" "Title of the booklet (BibTeX converts it to lowercase)")) (("author" "Author1 [and Author2 ...] [and others]") ("howpublished" "The way in which the booklet was published") ("address" "Address of the publisher") ("month" "Month of the publication as a string (remove braces)") ("year" "Year of publication") ("note" "Remarks to be put at the end of the \\bibitem")))) ("InBook" ((("author" "Author1 [and Author2 ...] [and others]" "" t) ("editor" "Editor1 [and Editor2 ...] [and others]" "" t) ("title" "Title of the book") ("chapter" "Chapter in the book") ("publisher" "Publishing company") ("year" "Year of publication")) (("volume" "Volume of the book in the series") ("number" "Number of the book in a small series (overwritten by volume)") ("series" "Series in which the book appeared") ("type" "Word to use instead of \"chapter\"") ("address" "Address of the publisher") ("edition" "Edition of the book as a capitalized English word") ("month" "Month of the publication as a string (remove braces)") ("pages" "Pages in the book") ("note" "Remarks to be put at the end of the \\bibitem"))) ((("author" "Author1 [and Author2 ...] [and others]" "" t) ("editor" "Editor1 [and Editor2 ...] [and others]" "" t) ("title" "Title of the book") ("chapter" "Chapter in the book")) (("pages" "Pages in the book") ("publisher" "Publishing company") ("year" "Year of publication") ("volume" "Volume of the book in the series") ("number" "Number of the book in a small series (overwritten by volume)") ("series" "Series in which the book appeared") ("type" "Word to use instead of \"chapter\"") ("address" "Address of the publisher") ("edition" "Edition of the book as a capitalized English word") ("month" "Month of the publication as a string (remove braces)") ("note" "Remarks to be put at the end of the \\bibitem")))) ("InCollection" ((("author" "Author1 [and Author2 ...] [and others]") ("title" "Title of the article in book (BibTeX converts it to lowercase)") ("booktitle" "Name of the book") ("publisher" "Publishing company") ("year" "Year of publication")) (("editor" "Editor1 [and Editor2 ...] [and others]") ("volume" "Volume of the book in the series") ("number" "Number of the book in a small series (overwritten by volume)") ("series" "Series in which the book appeared") ("type" "Word to use instead of \"chapter\"") ("chapter" "Chapter in the book") ("pages" "Pages in the book") ("address" "Address of the publisher") ("edition" "Edition of the book as a capitalized English word") ("month" "Month of the publication as a string (remove braces)") ("note" "Remarks to be put at the end of the \\bibitem"))) ((("author" "Author1 [and Author2 ...] [and others]") ("title" "Title of the article in book (BibTeX converts it to lowercase)") ("booktitle" "Name of the book")) (("pages" "Pages in the book") ("publisher" "Publishing company") ("year" "Year of publication") ("editor" "Editor1 [and Editor2 ...] [and others]") ("volume" "Volume of the book in the series") ("number" "Number of the book in a small series (overwritten by volume)") ("series" "Series in which the book appeared") ("type" "Word to use instead of \"chapter\"") ("chapter" "Chapter in the book") ("address" "Address of the publisher") ("edition" "Edition of the book as a capitalized English word") ("month" "Month of the publication as a string (remove braces)") ("note" "Remarks to be put at the end of the \\bibitem")))) ("InProceedings" ((("author" "Author1 [and Author2 ...] [and others]") ("title" "Title of the article in proceedings (BibTeX converts it to lowercase)") ("booktitle" "Name of the conference proceedings") ("year" "Year of publication")) (("editor" "Editor1 [and Editor2 ...] [and others]") ("volume" "Volume of the conference proceedings in the series") ("number" "Number of the conference proceedings in a small series (overwritten by volume)") ("series" "Series in which the conference proceedings appeared") ("pages" "Pages in the conference proceedings") ("address" "Location of the Proceedings") ("month" "Month of the publication as a string (remove braces)") ("organization" "Sponsoring organization of the conference") ("publisher" "Publishing company, its location") ("note" "Remarks to be put at the end of the \\bibitem"))) ((("author" "Author1 [and Author2 ...] [and others]") ("title" "Title of the article in proceedings (BibTeX converts it to lowercase)")) (("booktitle" "Name of the conference proceedings") ("pages" "Pages in the conference proceedings") ("year" "Year of publication") ("editor" "Editor1 [and Editor2 ...] [and others]") ("volume" "Volume of the conference proceedings in the series") ("number" "Number of the conference proceedings in a small series (overwritten by volume)") ("series" "Series in which the conference proceedings appeared") ("address" "Location of the Proceedings") ("month" "Month of the publication as a string (remove braces)") ("organization" "Sponsoring organization of the conference") ("publisher" "Publishing company, its location") ("note" "Remarks to be put at the end of the \\bibitem")))) ("Manual" ((("title" "Title of the manual")) (("author" "Author1 [and Author2 ...] [and others]") ("organization" "Publishing organization of the manual") ("address" "Address of the organization") ("edition" "Edition of the manual as a capitalized English word") ("month" "Month of the publication as a string (remove braces)") ("year" "Year of publication") ("note" "Remarks to be put at the end of the \\bibitem")))) ("MastersThesis" ((("author" "Author1 [and Author2 ...] [and others]") ("title" "Title of the master's thesis (BibTeX converts it to lowercase)") ("school" "School where the master's thesis was written") ("year" "Year of publication")) (("type" "Type of the master's thesis (if other than \"Master's thesis\")") ("address" "Address of the school (if not part of field \"school\") or country") ("month" "Month of the publication as a string (remove braces)") ("note" "Remarks to be put at the end of the \\bibitem")))) ("Misc" (nil (("author" "Author1 [and Author2 ...] [and others]") ("title" "Title of the work (BibTeX converts it to lowercase)") ("howpublished" "The way in which the work was published") ("month" "Month of the publication as a string (remove braces)") ("year" "Year of publication") ("note" "Remarks to be put at the end of the \\bibitem")))) ("PhdThesis" ((("author" "Author1 [and Author2 ...] [and others]") ("title" "Title of the PhD. thesis") ("school" "School where the PhD. thesis was written") ("year" "Year of publication")) (("type" "Type of the PhD. thesis") ("address" "Address of the school (if not part of field \"school\") or country") ("month" "Month of the publication as a string (remove braces)") ("note" "Remarks to be put at the end of the \\bibitem")))) ("Proceedings" ((("title" "Title of the conference proceedings") ("year" "Year of publication")) (("booktitle" "Title of the proceedings for cross references") ("editor" "Editor1 [and Editor2 ...] [and others]") ("volume" "Volume of the conference proceedings in the series") ("number" "Number of the conference proceedings in a small series (overwritten by volume)") ("series" "Series in which the conference proceedings appeared") ("address" "Location of the Proceedings") ("month" "Month of the publication as a string (remove braces)") ("organization" "Sponsoring organization of the conference") ("publisher" "Publishing company, its location") ("note" "Remarks to be put at the end of the \\bibitem")))) ("TechReport" ((("author" "Author1 [and Author2 ...] [and others]") ("title" "Title of the technical report (BibTeX converts it to lowercase)") ("institution" "Sponsoring institution of the report") ("year" "Year of publication")) (("type" "Type of the report (if other than \"technical report\")") ("number" "Number of the technical report") ("address" "Address of the institution (if not part of field \"institution\") or country") ("month" "Month of the publication as a string (remove braces)") ("note" "Remarks to be put at the end of the \\bibitem")))) ("Unpublished" ((("author" "Author1 [and Author2 ...] [and others]") ("title" "Title of the unpublished work (BibTeX converts it to lowercase)") ("note" "Remarks to be put at the end of the \\bibitem")) (("month" "Month of the publication as a string (remove braces)") ("year" "Year of publication")))))) nil "Defines entry types and their associated fields.
List of
(ENTRY-NAME (REQUIRED OPTIONAL) (CROSSREF-REQUIRED CROSSREF-OPTIONAL))
triples.
If the third element is nil, the first pair is always used.
If not, the second pair is used in the case of presence of a crossref
field and the third in the case of absence.
REQUIRED, OPTIONAL, CROSSREF-REQUIRED and CROSSREF-OPTIONAL are lists.
Each element of these lists is a list of the form
(FIELD-NAME COMMENT-STRING INIT ALTERNATIVE-FLAG).
COMMENT-STRING, INIT, and ALTERNATIVE-FLAG are optional.
FIELD-NAME is the name of the field, COMMENT-STRING the comment to
appear in the echo area, INIT is either the initial content of the
field or a function, which is called to determine the initial content
of the field, and ALTERNATIVE-FLAG (either nil or t) marks if the
field is an alternative.  ALTERNATIVE-FLAG may be t only in the
REQUIRED or CROSSREF-REQUIRED lists." nil [7393 22380]) ("bibtex-comment-start" variable nil "@Comment " nil nil nil [22382 22423]) ("bibtex-add-entry-hook" variable nil nil nil "List of functions to call when entry has been inserted." nil [22425 22553]) ("bibtex-predefined-month-strings" variable nil (quote (("jan") ("feb") ("mar") ("apr") ("may") ("jun") ("jul") ("aug") ("sep") ("oct") ("nov") ("dec"))) nil "Alist of month string definitions.
Should contain all strings used for months in the BibTeX style files.
Each element is a list with just one element: the string." nil [22555 22932]) ("bibtex-predefined-strings" variable nil (append bibtex-predefined-month-strings (quote (("acmcs") ("acta") ("cacm") ("ibmjrd") ("ibmsj") ("ieeese") ("ieeetc") ("ieeetcad") ("ipl") ("jacm") ("jcss") ("scp") ("sicomp") ("tcs") ("tocs") ("tods") ("tog") ("toms") ("toois") ("toplas")))) nil "Alist of string definitions.
Should contain the strings defined in the BibTeX style files.  Each
element is a list with just one element: the string." nil [22934 23449]) ("bibtex-string-files" variable nil nil ((user-visible . t)) "*List of BibTeX files containing string definitions.
Those files must be specified using pathnames relative to the
directories specified in `bibtex-string-file-path'.  This variable is only
evaluated when BibTeX mode is entered (i.e., when loading the BibTeX
file)." nil [23451 23796]) ("bibtex-string-file-path" variable nil (getenv "BIBINPUTS") ((user-visible . t)) "*Colon separated list of paths to search for `bibtex-string-files'." nil [23798 23923]) ("bibtex-help-message" variable nil t ((user-visible . t)) "*If not nil print help messages in the echo area on entering a new field." nil [23925 24070]) ("bibtex-autokey-prefix-string" variable nil "" ((user-visible . t)) "*String to use as a prefix for all generated keys.
See the documentation of function `bibtex-generate-autokey' for more detail." nil [24072 24288]) ("bibtex-autokey-names" variable nil 1 ((user-visible . t)) "*Number of names to use for the automatically generated reference key.
If this is variable is nil, all names are used.
Possibly more names are used according to `bibtex-autokey-names-stretch'.
See the documentation of function `bibtex-generate-autokey' for more detail." nil [24290 24677]) ("bibtex-autokey-names-stretch" variable nil 0 ((user-visible . t)) "*Number of names that can additionally be used.
These names are used only, if all names are used then.
See the documentation of function `bibtex-generate-autokey' for details." nil [24679 24943]) ("bibtex-autokey-additional-names" variable nil "" ((user-visible . t)) "*String to prepend to the generated key if not all names could be used.
See the documentation of function `bibtex-generate-autokey' for details." nil [24945 25181]) ("bibtex-autokey-transcriptions" variable nil (quote (("\\\\aa" "a") ("\\\\AA" "A") ("\\\"a\\|\\\\\\\"a\\|\\\\ae" "ae") ("\\\"A\\|\\\\\\\"A\\|\\\\AE" "Ae") ("\\\\i" "i") ("\\\\j" "j") ("\\\\l" "l") ("\\\\L" "L") ("\\\"o\\|\\\\\\\"o\\|\\\\o\\|\\\\oe" "oe") ("\\\"O\\|\\\\\\\"O\\|\\\\O\\|\\\\OE" "Oe") ("\\\"s\\|\\\\\\\"s" "ss") ("\\\"u\\|\\\\\\\"u" "ue") ("\\\"U\\|\\\\\\\"U" "Ue") ("\\\\`\\|\\\\'\\|\\\\\\^\\|\\\\~\\|\\\\=\\|\\\\\\.\\|\\\\u\\|\\\\v\\|\\\\H\\|\\\\t\\|\\\\c\\|\\\\d\\|\\\\b" "") ("{" "") ("}" ""))) nil "Alist of (old-regexp new-string) pairs.
Used by the default values of `bibtex-autokey-name-change-strings' and
`bibtex-autokey-titleword-change-strings'.  Defaults to translating some
language specific characters to their ASCII transcriptions, and
removing any character accents." nil [25183 26094]) ("bibtex-autokey-name-change-strings" variable nil bibtex-autokey-transcriptions nil "Alist of (OLD-REGEXP NEW-STRING) pairs.
Any part of name matching a OLD-REGEXP is replaced by NEW-STRING.
Case is significant in OLD-REGEXP.  All regexps are tried in the
order in which they appear in the list, so be sure to avoid inifinite
loops here.
See the documentation of function `bibtex-generate-autokey' for details." nil [26096 26599]) ("bibtex-autokey-name-case-convert" variable nil (quote downcase) ((user-visible . t)) "*Function called for each name to perform case conversion.
See the documentation of function `bibtex-generate-autokey' for more detail." nil [26601 27025]) ("bibtex-autokey-name-length" variable nil (quote infty) ((user-visible . t)) "*Number of characters from name to incorporate into key.
If this is set to anything but a number, all characters are used.
See the documentation of function `bibtex-generate-autokey' for details." nil [27027 27351]) ("bibtex-autokey-name-separator" variable nil "" ((user-visible . t)) "*String that comes between any two names in the key.
See the documentation of function `bibtex-generate-autokey' for details." nil [27353 27568]) ("bibtex-autokey-year-length" variable nil 2 ((user-visible . t)) "*Number of rightmost digits from the year field to incorporate into key.
See the documentation of function `bibtex-generate-autokey' for details." nil [27570 27802]) ("bibtex-autokey-year-use-crossref-entry" variable nil t ((user-visible . t)) "*If non-nil use year field from crossreferenced entry if necessary.
If this variable is non-nil and the current entry has no year, but a
valid crossref entry, the year field from the crossreferenced entry is
used.
See the documentation of function `bibtex-generate-autokey' for details." nil [27804 28189]) ("bibtex-autokey-titlewords" variable nil 5 ((user-visible . t)) "*Number of title words to use for the automatically generated reference key.
If this is set to anything but a number, all title words are used.
Possibly more words from the title are used according to
`bibtex-autokey-titlewords-stretch'.
See the documentation of function `bibtex-generate-autokey' for details." nil [28191 28624]) ("bibtex-autokey-title-terminators" variable nil (quote ("\\." "!" "\\?" ":" ";" "--")) ((user-visible . t)) "*Regexp list defining the termination of the main part of the title.
Case of the regexps is ignored.
See the documentation of function `bibtex-generate-autokey' for details." nil [28626 28933]) ("bibtex-autokey-titlewords-stretch" variable nil 2 ((user-visible . t)) "*Number of words that can additionally be used from the title.
These words are used only, if a sentence from the title can be ended then.
See the documentation of function `bibtex-generate-autokey' for details." nil [28935 29239]) ("bibtex-autokey-titleword-ignore" variable nil (quote ("A" "An" "On" "The" "Eine?" "Der" "Die" "Das" "[^A-Z].*" ".*[^a-zA-Z0-9].*")) ((user-visible . t)) "*Determines words from the title that are not to be used in the key.
Each item of the list is a regexp.  If a word of the title matchs a
regexp from that list, it is not included in the title part of the key.
See the documentation of function `bibtex-generate-autokey' for details." nil [29241 29705]) ("bibtex-autokey-titleword-case-convert" variable nil (quote downcase) ((user-visible . t)) "*Function called for each titleword to perform case conversion.
See the documentation of function `bibtex-generate-autokey' for more detail." nil [29707 30141]) ("bibtex-autokey-titleword-abbrevs" variable nil nil ((user-visible . t)) "*Determines exceptions to the usual abbreviation mechanism.
An alist of (OLD-REGEXP NEW-STRING) pairs.  Case is ignored
in matching against OLD-REGEXP, and the first matching pair is used.
See the documentation of function `bibtex-generate-autokey' for details." nil [30143 30457]) ("bibtex-autokey-titleword-change-strings" variable nil bibtex-autokey-transcriptions nil "Alist of (OLD-REGEXP NEW-STRING) pairs.
Any part of title word matching a OLD-REGEXP is replaced by NEW-STRING.
Case is significant in OLD-REGEXP.  All regexps are tried in the
order in which they appear in the list, so be sure to avoid inifinite
loops here.
See the documentation of function `bibtex-generate-autokey' for details." nil [30459 30973]) ("bibtex-autokey-titleword-length" variable nil 5 ((user-visible . t)) "*Number of characters from title words to incorporate into key.
If this is set to anything but a number, all characters are used.
See the documentation of function `bibtex-generate-autokey' for details." nil [30975 31306]) ("bibtex-autokey-titleword-separator" variable nil "_" ((user-visible . t)) "*String to be put between the title words.
See the documentation of function `bibtex-generate-autokey' for details." nil [31308 31519]) ("bibtex-autokey-name-year-separator" variable nil "" ((user-visible . t)) "*String to be put between name part and year part of key.
See the documentation of function `bibtex-generate-autokey' for details." nil [31521 31746]) ("bibtex-autokey-year-title-separator" variable nil ":_" ((user-visible . t)) "*String to be put between name part and year part of key.
See the documentation of function `bibtex-generate-autokey' for details." nil [31748 31976]) ("bibtex-autokey-edit-before-use" variable nil t ((user-visible . t)) "*If non-nil, user is allowed to edit the generated key before it is used." nil [31978 32142]) ("bibtex-autokey-before-presentation-function" variable nil nil nil "Function to call before the generated key is presented.
If non-nil this should be a single function, which is called before
the generated key is presented (in entry or, if
`bibtex-autokey-edit-before-use' is t, in minibuffer).  This function
must take one argument (the automatically generated key), and must
return with a string (the key to use)." nil [32144 32598]) ("bibtex-entry-offset" variable nil 0 ((user-visible . t)) "*Offset for BibTeX entries.
Added to the value of all other variables which determine colums." nil [32600 32765]) ("bibtex-field-indentation" variable nil 2 ((user-visible . t)) "*Starting column for the name part in BibTeX fields." nil [32767 32896]) ("bibtex-text-indentation" variable nil (+ bibtex-field-indentation (length "organization = ")) ((user-visible . t)) "*Starting column for the text part in BibTeX fields.
Should be equal to the space needed for the longest name part." nil [32898 33151]) ("bibtex-contline-indentation" variable nil (+ bibtex-text-indentation 1) ((user-visible . t)) "*Starting column for continuation lines of BibTeX fields." nil [33153 33320]) ("bibtex-align-at-equal-sign" variable nil nil ((user-visible . t)) "*If non-nil, align fields at equal sign instead of field text.
If non-nil, the column for the equal sign is
the value of `bibtex-text-indentation', minus 2." nil [33322 33559]) ("bibtex-comma-after-last-field" variable nil nil ((user-visible . t)) "*If non-nil, a comma is put at end of last field in the entry template." nil [33561 33716]) ("XEmacs-p" variable nil (string-match "[Xx][Ee][Mm][Aa][Ac][Ss]" (emacs-version)) ((const . t)) nil nil [33942 34021]) ("if" code nil [34023 34284]) ("if" code nil [34286 34723]) ("if" code nil [34725 34935]) ("bibtex-hs-forward-sexp" function nil ("arg") nil "Replacement for `forward-sexp' to be used by `hs-minor-mode'." nil [34988 35268]) ("add-to-list" code nil [35270 35375]) ("bibtex-mode-syntax-table" variable nil (let ((st (make-syntax-table))) (modify-syntax-entry 34 "\"" st) (modify-syntax-entry 36 "$$  " st) (modify-syntax-entry 37 "<   " st) (modify-syntax-entry 39 "w   " st) (modify-syntax-entry 64 "w   " st) (modify-syntax-entry 92 "\\" st) (modify-syntax-entry 12 ">   " st) (modify-syntax-entry 10 ">   " st) (modify-syntax-entry 126 " " st) st) nil nil nil [35430 35853]) ("bibtex-mode-map" variable nil (let ((km (make-sparse-keymap))) (define-key km "	" (quote bibtex-find-text)) (define-key km "
" (quote bibtex-next-field)) (define-key km "\211" (quote bibtex-complete-string)) (define-key km [(meta tab)] (quote bibtex-complete-key)) (define-key km "\"" (quote bibtex-remove-delimiters)) (define-key km "{" (quote bibtex-remove-delimiters)) (define-key km "}" (quote bibtex-remove-delimiters)) (define-key km "" (quote bibtex-clean-entry)) (define-key km "" (quote bibtex-fill-entry)) (define-key km "?" (quote bibtex-print-help-message)) (define-key km "" (quote bibtex-pop-previous)) (define-key km "" (quote bibtex-pop-next)) (define-key km "" (quote bibtex-kill-field)) (define-key km "\353" (quote bibtex-copy-field-as-kill)) (define-key km "" (quote bibtex-kill-entry)) (define-key km "\367" (quote bibtex-copy-entry-as-kill)) (define-key km "" (quote bibtex-yank)) (define-key km "\371" (quote bibtex-yank-pop)) (define-key km "" (quote bibtex-empty-field)) (define-key km "" (quote bibtex-make-field)) (define-key km "$" (quote bibtex-ispell-abstract)) (define-key km "\201" (quote bibtex-beginning-of-entry)) (define-key km "\205" (quote bibtex-end-of-entry)) (define-key km "\214" (quote bibtex-reposition-window)) (define-key km "\210" (quote bibtex-mark-entry)) (define-key km "" (quote bibtex-entry)) (define-key km "n" (quote bibtex-narrow-to-entry)) (define-key km "w" (quote widen)) (define-key km "" (quote bibtex-remove-OPT-or-ALT)) (define-key km "	" (quote bibtex-InProceedings)) (define-key km "i" (quote bibtex-InCollection)) (define-key km "I" (quote bibtex-InBook)) (define-key km "" (quote bibtex-Article)) (define-key km "" (quote bibtex-InBook)) (define-key km "b" (quote bibtex-Book)) (define-key km "B" (quote bibtex-Booklet)) (define-key km "" (quote bibtex-InCollection)) (define-key km "" (quote bibtex-Manual)) (define-key km "m" (quote bibtex-MastersThesis)) (define-key km "M" (quote bibtex-Misc)) (define-key km "" (quote bibtex-InProceedings)) (define-key km "p" (quote bibtex-Proceedings)) (define-key km "P" (quote bibtex-PhdThesis)) (define-key km "\360" (quote bibtex-Preamble)) (define-key km "" (quote bibtex-String)) (define-key km "" (quote bibtex-TechReport)) (define-key km "" (quote bibtex-Unpublished)) km) nil nil nil [35855 38379]) ("easy-menu-define" code nil [38381 40412]) ("easy-menu-define" code nil [40414 41247]) ("bibtex-pop-previous-search-point" variable nil nil nil nil nil [41274 41319]) ("bibtex-pop-next-search-point" variable nil nil nil nil nil [41400 41441]) ("bibtex-field-kill-ring" variable nil nil nil nil nil [41515 41550]) ("bibtex-field-kill-ring-yank-pointer" variable nil nil nil nil nil [41652 41700]) ("bibtex-entry-kill-ring" variable nil nil nil nil nil [41775 41810]) ("bibtex-entry-kill-ring-yank-pointer" variable nil nil nil nil nil [41913 41961]) ("bibtex-last-kill-command" variable nil nil nil nil nil [42036 42073]) ("bibtex-strings" variable nil nil nil nil nil [42144 42171]) ("make-variable-buffer-local" code nil [42285 42329]) ("bibtex-reference-keys" variable nil nil nil nil nil [42331 42365]) ("make-variable-buffer-local" code nil [42551 42602]) ("bibtex-buffer-last-parsed-tick" variable nil nil nil nil nil [42604 42647]) ("make-variable-buffer-local" code nil [42754 42814]) ("bibtex-parse-idle-timer" variable nil nil nil nil nil [42816 42852]) ("bibtex-progress-lastperc" variable nil nil nil nil nil [42894 42931]) ("bibtex-progress-lastmes" variable nil nil nil nil nil [42996 43032]) ("bibtex-progress-interval" variable nil nil nil nil nil [43078 43115]) ("bibtex-key-history" variable nil nil nil nil nil [43146 43177]) ("bibtex-entry-type-history" variable nil nil nil nil nil [43230 43268]) ("bibtex-field-history" variable nil nil nil nil nil [43328 43361]) ("bibtex-reformat-previous-options" variable nil nil nil nil nil [43421 43466]) ("bibtex-reformat-previous-reference-keys" variable nil nil nil nil nil [43517 43569]) ("bibtex-field-name" variable nil "[^\"#%'(),={} 	
0-9][^\"#%'(),={} 	
]*" ((const . t)) nil nil [43678 43751]) ("bibtex-entry-type" variable nil (concat "@" bibtex-field-name) ((const . t)) nil nil [43805 43864]) ("bibtex-reference-key" variable nil "[][a-zA-Z0-9.:;?!`'/*@+=|()<>&_^$-]+" ((const . t)) nil nil [43918 43988]) ("bibtex-parse-nested-braces" function nil ("nesting-level") nil "*Starting on an opening brace, find the corresponding closing brace.
When the function is called, NESTING-LEVEL has to be set to `0'." nil [44050 44532]) ("bibtex-parse-field-string-braced" function nil nil nil "*Parse a field string enclosed by braces.
The field string has to be syntactically correct, which means that the number
of opening and closing braces has to match.  If this is the case, a pair
containing the start and end position of the field string is returned, nil
otherwise." nil [44534 45109]) ("bibtex-parse-quoted-string" function nil nil nil "*Starting on an opening quote, find the corresponding closing quote." nil [45111 45527]) ("bibtex-parse-field-string-quoted" function nil nil nil "*Parse a field string enclosed by quotes.
If a syntactically correct string is found, a pair containing the start and
end position of the field string is returned, nil otherwise." nil [45529 46004]) ("bibtex-parse-field-string" function nil nil nil "*Parse a field string enclosed by braces or quotes.
If a syntactically correct string is found, a pair containing the start and
end position of the field string is returned, nil otherwise." nil [46006 46438]) ("bibtex-search-forward-field-string" function nil ("bound") nil "*Search forward to find a field string enclosed by braces or quotes.
If a syntactically correct string is found, a pair containing the start and
end position of the field string is returned, nil otherwise.  The search is
delimited by BOUND." nil [46440 47256]) ("bibtex-parse-association" function nil ("parse-lhs" "parse-rhs") nil "*Parse a string of the format <left hand side = right-hand-side>.
The functions PARSE-LHS and PARSE-RHS are used to parse the corresponding
substrings.  These functions are expected to return nil if parsing is not
successfull.  If both functions return non-nil, a pair containing the returned
values of the functions PARSE-LHS and PARSE-RHSis returned." nil [47258 47993]) ("bibtex-field-name-for-parsing" variable nil nil nil nil nil [47995 48037]) ("make-variable-buffer-local" code nil [48150 48209]) ("bibtex-parse-field-name" function nil nil nil "*Parse the field name stored in bibtex-field-name-for-parsing.
If the field name is found, return a triple consisting of the position of the
very first character of the match, the actual starting position of the name
part and end position of the match." nil [48211 48764]) ("bibtex-field-const" variable nil "[][a-zA-Z0-9.:;?!`'/*@+=|<>&_^$-]+" ((const . t)) nil nil [48766 48832]) ("bibtex-parse-field-text" function nil nil nil "*Parse the text part of a BibTeX field.
The text part is either a string, or an empty string, or a constant followed
by one or more <# (string|constant)> pairs.  If a syntactically correct text
is found, a pair containing the start and end position of the text is
returned, nil otherwise." nil [48877 49705]) ("bibtex-parse-field" function nil ("name") nil "*Parse a BibTeX field of regexp NAME.
If a syntactically correct field is found, a pair containing the boundaries of
the name and text parts of the field is returned." nil [49707 50041]) ("bibtex-search-forward-field" function nil ("name" "bound") nil "*Search forward to find a field of name NAME.
If a syntactically correct field is found, a pair containing the boundaries of
the name and text parts of the field is returned.  The search is limited by
BOUND." nil [50043 50853]) ("bibtex-search-backward-field" function nil ("name" "bound") nil "*Search backward to find a field of name NAME.
If a syntactically correct field is found, a pair containing the boundaries of
the name and text parts of the field is returned.  The search is limited by
BOUND." nil [50855 51568]) ("bibtex-start-of-field" function nil ("bounds") nil (car (car bounds)) nil [51570 51629]) ("bibtex-end-of-field" function nil ("bounds") nil (cdr (cdr bounds)) nil [51630 51687]) ("bibtex-start-of-name-in-field" function nil ("bounds") nil (car (cdr (car bounds))) nil [51688 51761]) ("bibtex-end-of-name-in-field" function nil ("bounds") nil (car (cdr (cdr (car bounds)))) nil [51762 51839]) ("bibtex-start-of-text-in-field" function nil ("bounds") nil (car (cdr bounds)) nil [51840 51907]) ("bibtex-end-of-text-in-field" function nil ("bounds") nil (cdr (cdr bounds)) nil [51908 51973]) ("bibtex-parse-string-prefix" function nil nil nil "*Parse the prefix part of a bibtex string, including the reference key.
If the string prefix is found, return a triple consisting of the position of
the very first character of the match, the actual starting position of the
reference key and the end position of the match." nil [51975 52592]) ("bibtex-parse-string-postfix" function nil nil nil "*Parse the postfix part of a bibtex string, including the text.
If the string postfix is found, return a triple consisting of the position of
the actual starting and ending position of the text and the very last
character of the string entry." nil [52594 53219]) ("bibtex-parse-string" function nil nil nil "*Parse a BibTeX string entry.
If a syntactically correct entry is found, a pair containing the boundaries of
the reference key and text parts of the entry is returned." nil [53221 53516]) ("bibtex-search-forward-string" function nil nil nil "*Search forward to find a bibtex string entry.
If a syntactically correct entry is found, a pair containing the boundaries of
the reference key and text parts of the string is returned." nil [53518 54185]) ("bibtex-search-backward-string" function nil nil nil "*Search backward to find a bibtex string entry.
If a syntactically correct entry is found, a pair containing the boundaries of
the reference key and text parts of the field is returned." nil [54187 54833]) ("bibtex-end-of-string" function nil ("bounds") nil (car (cdr (cdr (cdr bounds)))) nil [54835 54905]) ("bibtex-start-of-reference-key-in-string" function nil ("bounds") nil (car (cdr (car bounds))) nil [54906 54989]) ("bibtex-end-of-reference-key-in-string" function nil ("bounds") nil (car (cdr (cdr (car bounds)))) nil [54990 55077]) ("bibtex-start-of-text-in-string" function nil ("bounds") nil (car (cdr bounds)) nil [55078 55146]) ("bibtex-end-of-text-in-string" function nil ("bounds") nil (car (cdr (cdr bounds))) nil [55147 55219]) ("bibtex-entry-head" variable nil (concat "^[ 	]*\\(" bibtex-entry-type "\\)[ 	]*[({][ 	
]*\\(" bibtex-reference-key "\\)") ((const . t)) nil nil [55221 55357]) ("bibtex-entry-maybe-empty-head" variable nil (concat bibtex-entry-head "?") ((const . t)) nil nil [55423 55496]) ("bibtex-type-in-head" variable nil 1 ((const . t)) nil nil [55610 55642]) ("bibtex-key-in-head" variable nil 2 ((const . t)) nil nil [55721 55752]) ("bibtex-entry-postfix" variable nil "[ 	
]*,?[ 	
]*[})]" ((const . t)) nil nil [55830 55886]) ("bibtex-key-in-entry" variable nil bibtex-key-in-head ((const . t)) nil nil [55937 55986]) ("bibtex-font-lock-keywords" variable nil (list (list bibtex-entry-maybe-empty-head (list bibtex-type-in-head (quote font-lock-function-name-face)) (list bibtex-key-in-head (quote font-lock-constant-face) nil t)) (list (concat "^\\([ 	]*" bibtex-comment-start ".*\\)$") 1 (quote font-lock-comment-face)) (list (concat "^[ 	]*\\(OPT" bibtex-field-name "\\)[ 	]*=") 1 (quote font-lock-comment-face)) (list (concat "^[ 	]*\\(" bibtex-field-name "\\)[ 	]*=") 1 (quote font-lock-variable-name-face)) "*Default expressions to highlight in BibTeX mode.") nil nil nil [56058 56745]) ("bibtex-delete-whitespace" function nil nil nil (if (looking-at "[ 	
]+") (delete-region (point) (match-end 0))) nil [56809 56964]) ("bibtex-current-line" function nil nil nil (+ (count-lines 1 (point)) (if (equal (current-column) 0) 1 0)) nil [56966 57154]) ("bibtex-member-of-regexp" function nil ("string" "list") nil (let* (case-fold-search) (while (and list (not (string-match (concat "^" (car list) "$") string))) (setq list (cdr list))) list) nil [57156 57501]) ("bibtex-assoc-of-regexp" function nil ("string" "alist") nil (let* ((case-fold-search t)) (while (and alist (not (string-match (concat "^" (car (car alist)) "$") string))) (setq alist (cdr alist))) (car alist)) nil [57503 57911]) ("bibtex-skip-to-valid-entry" function nil ("&optional" "backward") nil (let* ((case-fold-search t) (valid-bibtex-entry (concat "@[ 	]*\\(" (mapconcat (lambda (type) (concat "\\(" (car type) "\\)")) bibtex-entry-field-alist "\\|") "\\)")) found) (while (and (not found) (not (if backward (bobp) (eobp)))) (let ((pnt (point))) (cond ((looking-at valid-bibtex-entry) (if (and (bibtex-search-entry nil nil t) (equal (match-beginning 0) pnt)) (setq found t))) ((and (not bibtex-sort-ignore-string-entries) (bibtex-parse-string)) (setq found t))) (if found (goto-char pnt) (if backward (progn (goto-char (1- pnt)) (if (re-search-backward "^[ 	]*\\(@\\)" nil (quote move)) (goto-char (match-beginning 1)))) (goto-char (1+ pnt)) (if (re-search-forward "^[ 	]*@" nil (quote move)) (forward-char -1))))))) nil [57913 59412]) ("bibtex-map-entries" function nil ("fun") nil (let* ((case-fold-search t)) (bibtex-beginning-of-entry) (while (re-search-forward bibtex-entry-maybe-empty-head nil t) (let ((pnt (point)) (entry-type (downcase (buffer-substring-no-properties (1+ (match-beginning bibtex-type-in-head)) (match-end bibtex-type-in-head)))) (reference-key (if (match-beginning bibtex-key-in-head) (buffer-substring-no-properties (match-beginning bibtex-key-in-head) (match-end bibtex-key-in-head)) ""))) (if (or (and (not bibtex-sort-ignore-string-entries) (string-equal "string" (downcase entry-type))) (assoc-ignore-case entry-type bibtex-entry-field-alist)) (funcall fun reference-key)) (goto-char pnt) (bibtex-end-of-entry)))) nil [59414 60676]) ("bibtex-progress-message" function nil ("&optional" "flag" "interval") nil (let* ((size (- (point-max) (point-min))) (perc (if (= size 0) 100 (/ (* 100 (- (point) (point-min))) size)))) (if (or (and (not flag) (>= perc (+ bibtex-progress-interval bibtex-progress-lastperc))) (stringp flag)) (progn (if (stringp flag) (progn (setq bibtex-progress-lastmes flag) (if interval (setq bibtex-progress-interval interval) (setq bibtex-progress-interval 5)))) (setq bibtex-progress-lastperc perc) (message (concat bibtex-progress-lastmes " (%d%%)") perc)) (if (equal flag (quote done)) (progn (message (concat bibtex-progress-lastmes " (done)")) (setq bibtex-progress-lastmes nil))))) nil [60678 61968]) ("bibtex-field-left-delimiter" function nil nil nil (if (equal bibtex-field-delimiters (quote braces)) "{" "\"") nil [61971 62134]) ("bibtex-field-right-delimiter" function nil nil nil (if (equal bibtex-field-delimiters (quote braces)) "}" "\"") nil [62136 62300]) ("bibtex-entry-left-delimiter" function nil nil nil (if (equal bibtex-entry-delimiters (quote braces)) "{" "(") nil [62302 62464]) ("bibtex-entry-right-delimiter" function nil nil nil (if (equal bibtex-entry-delimiters (quote braces)) "}" ")") nil [62466 62629]) ("bibtex-search-entry" function nil ("empty-head" "&optional" "bound" "noerror" "backward") nil (let ((pnt (point)) (prefix (if empty-head bibtex-entry-maybe-empty-head bibtex-entry-head))) (if backward (let (found) (while (and (not found) (re-search-backward prefix bound noerror)) (setq found (bibtex-search-entry empty-head pnt t))) (if found (goto-char (match-beginning 0)) (if (equal noerror nil) (error "Search of BibTeX entry failed")) (if (equal noerror t) (goto-char pnt)) nil)) (let ((limit (if bound bound (point-max))) md found) (while (and (not found) (re-search-forward prefix bound noerror)) (setq md (match-data)) (let ((entry-closer (if (save-excursion (goto-char (match-end bibtex-type-in-head)) (looking-at "[ 	]*(")) ")" "}"))) (let ((infix-start (point)) (finished nil)) (while (not finished) (if (and (looking-at "[ 	
]*") (<= (match-end 0) limit)) (goto-char (match-end 0))) (let ((bounds (bibtex-parse-field bibtex-field-name))) (if (and bounds (<= (bibtex-end-of-field bounds) limit)) (progn (goto-char (bibtex-end-of-field bounds)) (setq infix-start (point))) (goto-char infix-start) (setq finished t))))) (if (and (looking-at bibtex-entry-postfix) (string-equal (buffer-substring-no-properties (1- (match-end 0)) (match-end 0)) entry-closer) (<= (match-end 0) limit)) (progn (re-search-forward bibtex-entry-postfix) (setq found t))))) (if found (progn (set-match-data md) (point)) (if (equal noerror nil) (error "Search of BibTeX entry failed")) (if (equal noerror t) (goto-char pnt)) nil)))) nil [62631 65749]) ("bibtex-flash-head" function nil nil nil (let* ((case-fold-search t) flash) (cond ((re-search-backward bibtex-entry-head nil t) (goto-char (match-beginning bibtex-type-in-head)) (setq flash (match-end bibtex-key-in-entry))) (t (end-of-line) (skip-chars-backward " 	") (setq flash (point)) (beginning-of-line) (skip-chars-forward " 	"))) (if (pos-visible-in-window-p (point)) (bibtex-sit-for 1) (message "From: %s" (buffer-substring (point) flash)))) nil [65751 66305]) ("bibtex-make-optional-field" function nil ("e-t") nil "Makes an optional field named E-T in current BibTeX entry." nil [66307 66540]) ("bibtex-move-outside-of-entry" function nil nil nil (let ((orig-point (point))) (bibtex-end-of-entry) (if (< (point) orig-point) (progn (goto-char orig-point) (beginning-of-line 1) (if (not (= 10 (char-before (1- (point))))) (progn (re-search-forward "^[ 	]*[@
]" nil (quote move)) (backward-char 1))))) (skip-chars-forward " 	
")) nil [66542 67191]) ("bibtex-beginning-of-first-entry" function nil nil nil (goto-char (point-min)) nil [67193 67426]) ("bibtex-beginning-of-last-entry" function nil nil nil (goto-char (point-max)) nil [67428 67641]) ("bibtex-inside-field" function nil nil nil (end-of-line) nil [67643 67942]) ("bibtex-enclosing-field" function nil ("&optional" "noerr") nil (let* ((case-fold-search t) (old-point (point)) (boe (bibtex-beginning-of-entry))) (goto-char old-point) (let ((bounds (bibtex-search-backward-field bibtex-field-name boe))) (if (and bounds (<= (bibtex-start-of-field bounds) old-point) (>= (bibtex-end-of-field bounds) old-point)) bounds (if noerr nil (error "Can't find enclosing BibTeX field"))))) nil [67944 68633]) ("bibtex-enclosing-entry-maybe-empty-head" function nil nil nil (let* ((case-fold-search t) (old-point (point))) (if (not (re-search-backward bibtex-entry-maybe-empty-head nil t)) (progn (error "Can't find enclosing BibTeX entry") (goto-char old-point))) (goto-char (match-beginning bibtex-type-in-head)) (if (not (bibtex-search-entry t nil t)) (progn (error "Can't find enclosing BibTeX entry") (goto-char old-point)))) nil [68635 69293]) ("bibtex-insert-current-kill" function nil ("n") nil (if (not bibtex-last-kill-command) (error "BibTeX kill ring is empty") (let* ((kr (if (equal bibtex-last-kill-command (quote field)) (quote bibtex-field-kill-ring) (quote bibtex-entry-kill-ring))) (kryp (if (equal bibtex-last-kill-command (quote field)) (quote bibtex-field-kill-ring-yank-pointer) (quote bibtex-entry-kill-ring-yank-pointer))) (ARGth-kill-element (nthcdr (mod (- n (length (eval kryp))) (length (eval kr))) (eval kr))) (current (car (set kryp ARGth-kill-element)))) (cond ((equal bibtex-last-kill-command (quote field)) (let (bibtex-help-message) (bibtex-find-text nil t) (if (looking-at "[}\"]") (forward-char))) (set-mark (point)) (message "Mark set") (bibtex-make-field (list (elt current 1) nil (elt current 2)) t)) ((equal bibtex-last-kill-command (quote entry)) (if (not (eobp)) (bibtex-beginning-of-entry)) (set-mark (point)) (message "Mark set") (insert (elt current 1))) (t (error "Unknown tag field: %s.  Please submit a bug report" bibtex-last-kill-command))))) nil [69295 70589]) ("bibtex-format-field-delimiters" function nil ("start" "stop") nil "*Replaces delimiters for field strings between START and STOP.
If the current delimiters equal the new delimiters, the buffer is not
changed." nil [70591 71312]) ("bibtex-format-entry" function nil nil nil (let* ((case-fold-search t) (beg (point)) (start (bibtex-beginning-of-entry)) crossref-there alternatives-there non-empty-alternative) (let ((end (copy-marker (bibtex-end-of-entry)))) (if (equal start (marker-position end)) (error "Not on a known BibTeX entry") (goto-char start) (let ((bounds (bibtex-search-forward-field bibtex-field-name end))) (while bounds (let ((begin-name (bibtex-start-of-name-in-field bounds)) (end-name (bibtex-end-of-name-in-field bounds)) (begin-text (bibtex-start-of-text-in-field bounds)) (end-text (bibtex-end-of-text-in-field bounds))) (goto-char begin-name) (if (looking-at "ALT") (progn (setq alternatives-there t) (goto-char begin-text) (if (not (looking-at "\\(\"\"\\)\\|\\({}\\)")) (setq non-empty-alternative t)))) (if (string-match "\\(OPT\\)?crossref" (buffer-substring-no-properties begin-name end-name)) (progn (setq crossref-there (buffer-substring-no-properties (1+ begin-text) (1- end-text))) (if (equal crossref-there "") (setq crossref-there nil))))) (goto-char (bibtex-end-of-field bounds)) (setq bounds (bibtex-search-forward-field bibtex-field-name end)))) (if (and alternatives-there (not non-empty-alternative)) (progn (goto-char beg) (error "All alternatives are empty"))) (goto-char start) (re-search-forward bibtex-entry-type end) (let* ((begin-type (1+ (match-beginning 0))) (end-type (match-end 0)) (entry-type (downcase (buffer-substring-no-properties begin-type end-type))) (entry-list (assoc-ignore-case entry-type bibtex-entry-field-alist)) (req (elt (elt entry-list 1) 0)) (creq (elt (elt entry-list 2) 0)) (format (if (equal bibtex-entry-format t) (quote (realign opts-or-alts numerical-fields last-comma page-dashes delimiters unify-case inherit-booktitle)) bibtex-entry-format)) field-done) (if (memq (quote unify-case) format) (progn (delete-region begin-type end-type) (insert (car entry-list)))) (if (memq (quote delimiters) format) (progn (goto-char end-type) (skip-chars-forward " 	
") (delete-char 1) (insert (bibtex-entry-left-delimiter)))) (goto-char start) (let ((bounds (bibtex-search-forward-field bibtex-field-name end))) (while bounds (let* ((begin-field (copy-marker (bibtex-start-of-field bounds))) (end-field (copy-marker (bibtex-end-of-field bounds))) (begin-name (copy-marker (bibtex-start-of-name-in-field bounds))) (end-name (copy-marker (bibtex-end-of-name-in-field bounds))) (begin-text (copy-marker (bibtex-start-of-text-in-field bounds))) (end-text (copy-marker (bibtex-end-of-text-in-field bounds))) (field-name (buffer-substring-no-properties (if (string-match "^\\(OPT\\)\\|\\(ALT\\)$" (buffer-substring-no-properties begin-name (+ begin-name 3))) (+ begin-name 3) begin-name) end-name))) (cond ((and (memq (quote opts-or-alts) format) (progn (goto-char begin-name) (looking-at "OPT\\|ALT"))) (goto-char begin-text) (if (looking-at "\\(\"\"\\)\\|\\({}\\)") (if (and (progn (goto-char begin-name) (looking-at "OPT")) (not crossref-there) (assoc-ignore-case field-name req)) (progn (goto-char begin-name) (bibtex-remove-OPT-or-ALT) (error "Mandatory field ``%s'' is empty" field-name)) (delete-region begin-field end-field)) (goto-char begin-name) (bibtex-remove-OPT-or-ALT))) ((and (memq (quote numerical-fields) format) (progn (goto-char begin-text) (looking-at "\\(\"[0-9]+\"\\)\\|\\({[0-9]+}\\)"))) (goto-char end-text) (delete-char -1) (goto-char begin-text) (delete-char 1)) (t (if (memq (quote delimiters) format) (bibtex-format-field-delimiters begin-text end-text)) (if (and (memq (quote page-dashes) format) (string-match "^\\(OPT\\)?pages$" (downcase field-name)) (progn (goto-char begin-text) (looking-at "\\([\"{][0-9]+\\)[ 	
]*--?[ 	
]*\\([0-9]+[\"}]\\)"))) (replace-match "\\1-\\2")) (if (and (memq (quote inherit-booktitle) format) (equal (downcase field-name) "booktitle") (progn (goto-char begin-text) (looking-at "\\(\"\"\\)\\|\\({}\\)")) crossref-there (not (bibtex-find-entry-location crossref-there t))) (let ((stop (bibtex-end-of-entry))) (bibtex-beginning-of-entry) (let ((bounds (bibtex-search-forward-field "title" stop))) (if bounds (progn (goto-char begin-text) (forward-char) (insert (buffer-substring-no-properties (1+ (bibtex-start-of-text-in-field bounds)) (1- (bibtex-end-of-text-in-field bounds))))))))) (if (progn (goto-char begin-text) (looking-at "\\(\"\"\\)\\|\\({}\\)")) (progn (forward-char) (if (or (and crossref-there (assoc-ignore-case field-name creq)) (and (not crossref-there) (assoc-ignore-case field-name req))) (error "Mandatory field ``%s'' is empty" field-name)))) (if (memq (quote unify-case) format) (let* ((fl (car (cdr (assoc-ignore-case entry-type bibtex-entry-field-alist)))) (field-list (append (elt fl 0) (elt fl 1) bibtex-user-optional-fields)) (new-field-name (car (assoc-ignore-case field-name field-list)))) (goto-char begin-name) (if new-field-name (progn (delete-region begin-name end-name) (insert new-field-name)) (downcase-region begin-name end-name)))) (setq field-done t))) (if (not field-done) (goto-char begin-field) (setq field-done nil) (goto-char end-field))) (setq bounds (bibtex-search-forward-field bibtex-field-name end)))) (if (looking-at (bibtex-field-right-delimiter)) (forward-char)) (if (memq (quote last-comma) format) (cond ((and bibtex-comma-after-last-field (not (looking-at ","))) (insert ",")) ((and (not bibtex-comma-after-last-field) (looking-at ",")) (delete-char 1)))) (if (looking-at ",") (forward-char)) (if (memq (quote delimiters) format) (progn (skip-chars-forward " 	
") (delete-char 1) (insert (bibtex-entry-right-delimiter)))) (if (memq (quote realign) format) (bibtex-fill-entry)))))) nil [71314 79153]) ("bibtex-autokey-change" function nil ("string" "change-list") nil (let* (case-fold-search (return-string string) (index 0) (len (length change-list)) change-item) (while (< index len) (setq change-item (elt change-list index)) (while (string-match (car change-item) return-string) (setq return-string (concat (substring return-string 0 (match-beginning 0)) (elt change-item 1) (substring return-string (match-end 0))))) (setq index (1+ index))) return-string) nil [79155 79846]) ("bibtex-autokey-abbrev" function nil ("string" "len") nil (cond ((or (not (numberp len)) (<= (length string) len)) string) ((equal len 0) "") (t (let* ((case-fold-search t) (abort-char (string-match "[^aeiou]" string (1- len)))) (if abort-char (substring string 0 (1+ abort-char)) string)))) nil [79848 80457]) ("bibtex-autokey-get-namefield" function nil ("min" "max") nil (goto-char min) nil [80459 81122]) ("bibtex-autokey-get-names" function nil ("namefield") nil (let* ((case-fold-search t) names) (while (not (equal namefield "")) (let (name) (if (string-match "[ 	
]and[ 	
]" namefield) (setq name (substring namefield 0 (match-beginning 0)) namefield (substring namefield (match-end 0))) (setq name namefield namefield "")) (setq names (append names (list name))))) names) nil [81124 81623]) ("bibtex-autokey-demangle-name" function nil ("fullname") nil (let* (case-fold-search (lastname (if (string-match "," fullname) (let ((von-last (substring fullname 0 (match-beginning 0)))) (if (string-match "^[a-z]" von-last) (if (string-match "[ 	][A-Z]" von-last) (substring von-last (1+ (match-beginning 0))) (error "Name %s is incorrectly formed" fullname)) von-last)) (if (string-match "[ 	]" fullname) (if (string-match "[ 	][a-z]" fullname) (if (string-match "[ 	][A-Z]" fullname (match-end 0)) (substring fullname (1+ (match-beginning 0))) (error "Name %s is incorrectly formed" fullname)) (if (string-match " [^ ]*$" fullname) (substring fullname (1+ (match-beginning 0))) (error "Name %s is incorrectly formed" fullname))) fullname))) (usename (if (string-match "[ 	]+" lastname) (substring lastname 0 (match-beginning 0)) lastname))) (funcall bibtex-autokey-name-case-convert usename)) nil [81625 83704]) ("bibtex-autokey-get-namelist" function nil ("namefield") nil (mapcar (lambda (fullname) (setq fullname (substring fullname (string-match "[^ 	]" fullname))) (bibtex-autokey-abbrev (bibtex-autokey-demangle-name fullname) bibtex-autokey-name-length)) (bibtex-autokey-get-names namefield)) nil [83706 84113]) ("bibtex-autokey-get-yearfield-digits" function nil ("max") nil (let ((bounds (bibtex-search-forward-field "year" max))) (if bounds (let ((year (buffer-substring-no-properties (bibtex-start-of-text-in-field bounds) (bibtex-end-of-text-in-field bounds)))) (string-match "[^0-9]*\\([0-9]+\\)" year) (substring year (match-beginning 1) (match-end 1))) "")) nil [84115 84529]) ("bibtex-autokey-get-yearfield" function nil ("min" "max") nil (goto-char min) nil [84531 85267]) ("bibtex-autokey-get-titlestring" function nil ("min" "max") nil (goto-char min) nil [85269 86012]) ("bibtex-autokey-get-titles" function nil ("titlestring") nil (let* (case-fold-search titlewords titlewords-extra (counter 0)) (while (and (not (equal titlestring "")) (or (not (numberp bibtex-autokey-titlewords)) (< counter (+ bibtex-autokey-titlewords bibtex-autokey-titlewords-stretch)))) (if (string-match "\\b\\w+" titlestring) (let* ((end-match (match-end 0)) (titleword (substring titlestring (match-beginning 0) end-match))) (if (bibtex-member-of-regexp titleword bibtex-autokey-titleword-ignore) (setq counter (1- counter)) (setq titleword (funcall bibtex-autokey-titleword-case-convert titleword)) (if (or (not (numberp bibtex-autokey-titlewords)) (< counter bibtex-autokey-titlewords)) (setq titlewords (append titlewords (list titleword))) (setq titlewords-extra (append titlewords-extra (list titleword))))) (setq titlestring (substring titlestring end-match))) (setq titlestring "")) (setq counter (1+ counter))) (if (string-match "\\b\\w+" titlestring) titlewords (append titlewords titlewords-extra))) nil [86014 87399]) ("bibtex-autokey-get-titlelist" function nil ("titlestring") nil (mapcar (lambda (titleword) (let ((abbrev (bibtex-assoc-of-regexp titleword bibtex-autokey-titleword-abbrevs))) (if abbrev (elt abbrev 1) (bibtex-autokey-abbrev titleword bibtex-autokey-titleword-length)))) (bibtex-autokey-get-titles titlestring)) nil [87401 87879]) ("bibtex-generate-autokey" function nil nil nil "Generates automatically a key from the author/editor and the title field.
This will only work for entries where each field begins on a separate line.
The generation algorithm works as follows:
 1. Use the value of `bibtex-autokey-prefix-string' as a prefix.
 2. If there is a non-empty author (preferred) or editor field,
    use it as the name part of the key.
 3. Change any substring found in
    `bibtex-autokey-name-change-strings' to the corresponding new
    one (see documentation of this variable for further detail).
 4. For every of at least first `bibtex-autokey-names' names in
    the name field, determine the last name. If there are maximal
    `bibtex-autokey-names' + `bibtex-autokey-names-stretch'
    names, all names are used.
 5. From every last name, take at least
    `bibtex-autokey-name-length' characters (abort only after a
    consonant or at a word end).
 6. Convert all last names according to the conversion function
    `bibtex-autokey-name-case-convert'.
 7. Build the name part of the key by concatenating all
    abbreviated last names with the string
    `bibtex-autokey-name-separator' between any two. If there are
    more names than are used in the name part, prepend the string
    contained in `bibtex-autokey-additional-names'.
 8. Build the year part of the key by truncating the contents of
    the year field to the rightmost `bibtex-autokey-year-length'
    digits (useful values are 2 and 4). If the year field is
    absent, but the entry has a valid crossref field and the
    variable `bibtex-autokey-year-use-crossref-entry' is non-nil,
    use the year field of the crossreferenced entry instead.
 9. For the title part of the key change the contents of the
    title field of the entry according to
    `bibtex-autokey-titleword-change-strings' to the
    corresponding new one (see documentation of this variable for
    further detail).
10. Abbreviate the result to the string up to (but not including)
    the first occurrence of a regexp matched by the items of
    `bibtex-autokey-title-terminators' and delete those words which
    appear in `bibtex-autokey-titleword-ignore'.
    Build the title part of the key by using at least the first
    `bibtex-autokey-titlewords' words from this
    abbreviated title. If the abbreviated title ends after
    maximal `bibtex-autokey-titlewords' +
    `bibtex-autokey-titlewords-stretch' words, all
    words from the abbreviated title are used.
11. Convert all used titlewords according to the conversion function
    `bibtex-autokey-titleword-case-convert'.
12. For every used title word that appears in
    `bibtex-autokey-titleword-abbrevs' use the corresponding
    abbreviation (see documentation of this variable for further
    detail).
13. From every title word not generated by an abbreviation, take
    at least `bibtex-autokey-titleword-length' characters (abort
    only after a consonant or at a word end).
14. Build the title part of the key by concatenating all
    abbreviated title words with the string
    `bibtex-autokey-titleword-separator' between any two.
15. At least, to get the key, concatenate
    `bibtex-autokey-prefix-string', the name part, the year part
    and the title part with `bibtex-autokey-name-year-separator'
    between the name part and the year part if both are non-empty
    and `bibtex-autokey-year-title-separator' between the year
    part and the title part if both are non-empty. If the year
    part is empty, but not the other two parts,
    `bibtex-autokey-year-title-separator' is used as well.
16. If the value of `bibtex-autokey-before-presentation-function'
    is non-nil, it must be a function taking one argument. This
    function is then called with the generated key as the
    argument. The return value of this function (a string) is
    used as the key.
17. If the value of `bibtex-autokey-edit-before-use' is non-nil,
    the key is then presented in the minibuffer to the user,
    where it can be edited.  The key given by the user is then
    used." nil [87881 94125]) ("bibtex-parse-keys" function nil ("add" "verbose" "&optional" "abortable") nil (if bibtex-maintain-sorted-entries (let* ((case-fold-search t) (reference-keys (if add bibtex-reference-keys))) (save-excursion (goto-char (point-min)) (if verbose (bibtex-progress-message (concat (buffer-name) ": parsing reference keys"))) (if (catch (quote userkey) (bibtex-skip-to-valid-entry) (while (not (eobp)) (if (and abortable (input-pending-p)) (throw (quote userkey) t)) (if verbose (bibtex-progress-message)) (let (reference-key xrefd-reference-key) (cond ((looking-at bibtex-entry-head) (setq reference-key (buffer-substring-no-properties (match-beginning bibtex-key-in-head) (match-end bibtex-key-in-head))) (let ((p (point)) (m (bibtex-end-of-entry))) (goto-char p) (let ((bounds (bibtex-search-forward-field "crossref" m))) (if bounds (setq xrefd-reference-key (buffer-substring-no-properties (1+ (bibtex-start-of-text-in-field bounds)) (1- (bibtex-end-of-text-in-field bounds)))))))) ((bibtex-parse-string) (let ((bounds (bibtex-parse-string))) (setq reference-key (buffer-substring-no-properties (bibtex-start-of-reference-key-in-string bounds) (bibtex-end-of-reference-key-in-string bounds)))))) (forward-char) (bibtex-skip-to-valid-entry) (if (not (assoc reference-key reference-keys)) (setq reference-keys (cons (list reference-key) reference-keys))) (if (and xrefd-reference-key (not (assoc xrefd-reference-key reference-keys))) (setq reference-keys (cons (list xrefd-reference-key) reference-keys)))))) nil (setq bibtex-buffer-last-parsed-tick (buffer-modified-tick) bibtex-reference-keys reference-keys) (if verbose (bibtex-progress-message (quote done))) t)))) nil [94127 97130]) ("bibtex-parse-buffers-stealthily" function nil nil nil (let ((buffers (buffer-list))) (save-excursion (while (and buffers (not (input-pending-p))) (set-buffer (car buffers)) (save-restriction (widen) (if (and (eq major-mode (quote bibtex-mode)) bibtex-maintain-sorted-entries (not (eq (buffer-modified-tick) bibtex-buffer-last-parsed-tick))) (if (bibtex-parse-keys nil t t) (setq buffers (cdr buffers))) (setq buffers (cdr buffers))))))) nil [97132 98035]) ("bibtex-complete" function nil ("string-list" "&optional" "complete-strings") nil (let* ((case-fold-search t) (end (point)) (beg (save-excursion (re-search-backward "[ 	{\"]") (forward-char) (point))) (part-of-word (buffer-substring-no-properties beg end)) (completions (copy-sequence string-list)) (completion (save-excursion (if complete-strings (while (bibtex-search-backward-string) (let ((bounds (bibtex-search-backward-string))) (setq completions (cons (list (buffer-substring-no-properties (bibtex-start-of-reference-key-in-string bounds) (bibtex-end-of-reference-key-in-string bounds))) completions))))) (setq completions (sort completions (lambda (x y) (string-lessp (car x) (car y))))) (try-completion part-of-word completions)))) (cond ((eq completion t) (if complete-strings (save-excursion (bibtex-inside-field) (let* ((bounds (bibtex-enclosing-field))) (goto-char (bibtex-start-of-text-in-field bounds)) (let ((boundaries (bibtex-parse-field-string))) (if (and boundaries (equal (cdr boundaries) (bibtex-end-of-text-in-field bounds))) (bibtex-remove-delimiters))))))) ((not completion) (error "Can't find completion for \"%s\"" part-of-word)) ((not (string= part-of-word completion)) (delete-region beg end) (insert completion) (if (and (assoc completion completions) complete-strings) (save-excursion (bibtex-inside-field) (let* ((bounds (bibtex-enclosing-field))) (goto-char (bibtex-start-of-text-in-field bounds)) (let ((boundaries (bibtex-parse-field-string))) (if (and boundaries (equal (cdr boundaries) (bibtex-end-of-text-in-field bounds))) (bibtex-remove-delimiters))))))) (t (message "Making completion list...") (let ((list (all-completions part-of-word completions))) (with-output-to-temp-buffer "*Completions*" (display-completion-list list))) (message "Making completion list...done")))) nil [98037 101082]) ("bibtex-do-auto-fill" function nil nil nil (let ((fill-prefix (make-string (+ bibtex-entry-offset bibtex-contline-indentation) 32))) (do-auto-fill)) nil [101084 101245]) ("bibtex-pop" function nil ("arg" "direction") nil (let (bibtex-help-message) (bibtex-find-text nil)) nil [101247 103922]) ("bibtex-mode" function nil nil ((user-visible . t)) "Major mode for editing BibTeX files.

To submit a problem report, enter \\[bibtex-submit-bug-report] from a
BibTeX mode buffer.  This automatically sets up a mail buffer with
version information already added.  You just need to add a description
of the problem, including a reproducable test case and send the
message.


General information on working with BibTeX mode:

You should use commands as \\[bibtex-Book] to get a template for a
specific entry. You should then fill in all desired fields using
\\[bibtex-next-field] to jump from field to field. After having filled
in all desired fields in the entry, you should clean the new entry
with command \\[bibtex-clean-entry].

Some features of BibTeX mode are available only by setting variable
bibtex-maintain-sorted-entries to t. However, then BibTeX mode will
work with buffer containing only valid (syntactical correct) entries
and with entries being sorted. This is usually the case, if you have
created a buffer completely with BibTeX mode and finished every new
entry with \\[bibtex-clean-entry].

For third party BibTeX buffers, please call the function
`bibtex-convert-alien' to fully take advantage of all features of
BibTeX mode.


Special information:

A command such as \\[bibtex-Book] will outline the fields for a BibTeX book entry.

The optional fields start with the string OPT, and are thus ignored by BibTeX.
Alternatives from which only one is required start with the string ALT.
The OPT or ALT string may be removed from a field with \\[bibtex-remove-OPT-or-ALT].
\\[bibtex-make-field] inserts a new field after the current one.
\\[bibtex-kill-field] kills the current field entirely.
\\[bibtex-yank] will yank the last recently killed field after the
current field.
\\[bibtex-remove-delimiters] removes the double-quotes or braces around the text of the current field.
 \\[bibtex-empty-field] replaces the text of the current field with the default \"\" or {}.

The command \\[bibtex-clean-entry] cleans the current entry, i.e. it removes OPT/ALT
from all non-empty optional or alternative fields, checks that no required
fields are empty, and does some formatting dependent on the value of
bibtex-entry-format.
Note: some functions in BibTeX mode depend on entries being in a special
format (all fields beginning on separate lines), so it is usually a bad
idea to remove `realign' from bibtex-entry-format.

Use \\[bibtex-find-text] to position the cursor at the end of the current field.
Use \\[bibtex-next-field] to move to end of the next field.

The following may be of interest as well:

  Functions:
    bibtex-entry
    bibtex-kill-entry
    bibtex-yank-pop
    bibtex-pop-previous
    bibtex-pop-next
    bibtex-complete-string
    bibtex-complete-key
    bibtex-print-help-message
    bibtex-generate-autokey
    bibtex-beginning-of-entry
    bibtex-end-of-entry
    bibtex-reposition-window
    bibtex-mark-entry
    bibtex-ispell-abstract
    bibtex-ispell-entry
    bibtex-narrow-to-entry
    bibtex-sort-buffer
    bibtex-validate
    bibtex-count
    bibtex-fill-entry
    bibtex-reformat
    bibtex-convert-alien

  Variables:
    bibtex-field-delimiters
    bibtex-include-OPTcrossref
    bibtex-include-OPTkey
    bibtex-user-optional-fields
    bibtex-entry-format
    bibtex-sort-ignore-string-entries
    bibtex-maintain-sorted-entries
    bibtex-entry-field-alist
    bibtex-predefined-strings
    bibtex-string-files

---------------------------------------------------------
Entry to BibTeX mode calls the value of `bibtex-mode-hook' if that value is
non-nil.

\\{bibtex-mode-map}" nil [103968 111208]) ("bibtex-submit-bug-report" function nil nil ((user-visible . t)) "Submit via mail a bug report on bibtex.el." nil [111210 114802]) ("bibtex-entry" function nil ("entry-type") ((user-visible . t)) "Insert a new BibTeX entry.
After insertion it calls the functions in `bibtex-add-entry-hook'." nil [114804 117012]) ("bibtex-print-help-message" function nil nil ((user-visible . t)) "Prints helpful information about current field in current BibTeX entry." nil [117014 118939]) ("bibtex-make-field" function nil ("e-t" "&optional" "called-by-yank") ((user-visible . t)) "Makes a field named E-T in current BibTeX entry.
This function is for interactive and non-interactive purposes.  To call
it interactively, just give it no arguments and enter the field name
using the minibuffer." nil [118941 121453]) ("bibtex-beginning-of-entry" function nil nil ((user-visible . t)) "Move to beginning of BibTeX entry.
If inside an entry, move to the beginning of it, otherwise move to the
beginning of the previous entry.
If called from a program, this function returns the new location of point." nil [121455 121843]) ("bibtex-end-of-entry" function nil nil ((user-visible . t)) "Move to end of BibTeX entry.
If inside an entry, move to the end of it, otherwise move to the end
of the previous entry.
If called from a program, this function returns the new location of point." nil [121845 123334]) ("bibtex-reposition-window" function nil ("arg") ((user-visible . t)) "Make the current BibTeX entry visible." nil [123336 123556]) ("bibtex-mark-entry" function nil nil ((user-visible . t)) "Put mark at beginning, point at end of current BibTeX entry." nil [123558 123732]) ("bibtex-count-entries" function nil ("&optional" "count-string-entries") ((user-visible . t)) "Count number of entries in current buffer or region.
With prefix argument COUNT-STRING-ENTRIES it counts all entries,
otherwise it counts all except Strings.
If mark is active it counts entries in region, if not in whole buffer." nil [123734 124736]) ("bibtex-ispell-entry" function nil nil ((user-visible . t)) "Spell whole BibTeX entry." nil [124738 124882]) ("bibtex-ispell-abstract" function nil nil ((user-visible . t)) "Spell abstract of BibTeX entry." nil [124884 125274]) ("bibtex-narrow-to-entry" function nil nil ((user-visible . t)) "Narrow buffer to current BibTeX entry." nil [125276 125465]) ("bibtex-sort-buffer" function nil nil ((user-visible . t)) "Sort BibTeX buffer alphabetically by key.
Text outside of BibTeX entries is not affected.  If
`bibtex-sort-ignore-string-entries' is non-nil, @String entries will be
ignored." nil [125467 126279]) ("bibtex-find-entry-location" function nil ("entry-name" "&optional" "ignore-dups") nil "Looking for place to put the BibTeX entry named ENTRY-NAME.
Performs a binary search (therefore, buffer is assumed to be in sorted
order, without duplicates (see \\[bibtex-validate]), if it is
not, `bibtex-find-entry-location' will fail).  If entry-name is already
used as a reference key, an error is signaled.  However, if optional
variable IGNORE-DUPS is non-nil, no error messages about duplicate
entries are signaled, but the error handling is assumed to be made in
the calling function.
The value is nil if an duplicate entry error occurred,
and t in all other cases." nil [126281 129057]) ("bibtex-validate" function nil ("&optional" "test-thoroughly") ((user-visible . t)) "Validate if buffer or region is syntactically correct.
Only known entry types are checked, so you can put comments
outside of entries.
With optional argument TEST-THOROUGHLY non-nil it checks for absence of
required fields and questionable month fields as well.
If mark is active, it validates current region, if not whole buffer.
Returns t if test was successful, nil otherwise." nil [129059 137601]) ("bibtex-next-field" function nil ("arg") ((user-visible . t)) "Finds end of text of next BibTeX field; with ARG, to its beginning." nil [137603 138016]) ("bibtex-find-text" function nil ("arg" "&optional" "as-if-interactive" "silent") ((user-visible . t)) "Go to end of text of current field; with ARG, go to beginning." nil [138018 139070]) ("bibtex-remove-OPT-or-ALT" function nil nil ((user-visible . t)) "Removes the string starting optional/alternative fields.
Aligns text and goes thereafter to end of text." nil [139072 139995]) ("bibtex-remove-delimiters" function nil nil ((user-visible . t)) "Removes \"\" or {} around string." nil [139997 140641]) ("bibtex-kill-field" function nil ("&optional" "copy-only") ((user-visible . t)) "Kills the entire enclosing BibTeX field.
With prefix arg COPY-ONLY, copy the current field to `bibtex-field-kill-ring,'
but do not actually kill it." nil [140643 141997]) ("bibtex-copy-field-as-kill" function nil nil nil (interactive) nil [141999 142075]) ("bibtex-kill-entry" function nil ("&optional" "copy-only") ((user-visible . t)) "Kill the entire enclosing BibTeX entry.
With prefix arg COPY-ONLY the current entry to
`bibtex-entry-kill-ring', but do not actually kill it." nil [142077 143040]) ("bibtex-copy-entry-as-kill" function nil nil nil (interactive) nil [143042 143118]) ("bibtex-yank" function nil ("&optional" "n") ((user-visible . t)) "Reinsert the last BibTeX item.
More precisely, reinsert the field or entry killed or yanked most recently.
With argument N, reinsert the Nth most recently killed BibTeX item.
See also the command \\[bibtex-yank-pop]]." nil [143120 143469]) ("bibtex-yank-pop" function nil ("n") ((user-visible . t)) "Replace just-yanked killed BibTeX item with a different.
This command is allowed only immediately after a `bibtex-yank' or a
`bibtex-yank-pop'.
At such a time, the region contains a reinserted previously killed
BibTeX item.  `bibtex-yank-pop' deletes that item and inserts in its
place a different killed BibTeX item.

With no argument, the previous kill is inserted.
With argument N, insert the Nth previous kill.
If N is negative, this is a more recent kill.

The sequence of kills wraps around, so that after the oldest one
comes the newest one." nil [143471 144310]) ("bibtex-empty-field" function nil nil ((user-visible . t)) "Delete the text part of the current field, replace with empty text." nil [144312 144732]) ("bibtex-pop-previous" function nil ("arg") ((user-visible . t)) "Replace text of current field with the similar field in previous entry.
With arg, goes up ARG entries.  Repeated, goes up so many times.  May be
intermixed with \\[bibtex-pop-next] (bibtex-pop-next)." nil [144734 145020]) ("bibtex-pop-next" function nil ("arg") ((user-visible . t)) "Replace text of current field with the text of similar field in next entry.
With arg, goes down ARG entries.  Repeated, goes down so many times.  May be
intermixed with \\[bibtex-pop-previous] (bibtex-pop-previous)." nil [145022 145316]) ("bibtex-clean-entry" function nil ("&optional" "new-reference-key" "called-by-reformat") ((user-visible . t)) "Finish editing the current BibTeX entry and clean it up.
Checks that no required fields are empty and formats entry dependent
on the value of bibtex-entry-format.
If the reference key of the entry is empty or a prefix argument is given,
calculate a new reference key (note: this only will work if fields in entry
begin on separate lines prior to calling bibtex-clean-entry or if 'realign is
contained in bibtex-entry-format).
Don't call this on `string' or `preamble' entries.
At end of the cleaning process, the functions in
bibtex-clean-entry-hook are called with region narrowed to entry." nil [145318 148308]) ("bibtex-fill-entry" function nil nil ((user-visible . t)) "Fill current entry.
Realigns entry, so that every field starts on a separate line.  Field
names appear in column `bibtex-field-indentation', field text starts in
column `bibtex-text-indentation' and continuation lines start here, too.
If `bibtex-align-at-equal-sign' is non-nil, align equal signs also." nil [148310 150169]) ("bibtex-reformat" function nil ("&optional" "additional-options" "called-by-convert-alien") ((user-visible . t)) "Reformat all BibTeX entries in buffer or region.
With prefix argument, read options for reformatting from minibuffer.
With \\[universal-argument] \\[universal-argument] prefix argument, reuse previous answers (if any) again.
If mark is active it reformats entries in region, if not in whole buffer." nil [150171 154391]) ("bibtex-convert-alien" function nil ("&optional" "do-additional-reformatting") ((user-visible . t)) "Converts an alien BibTeX buffer to be fully usable by BibTeX mode.
If a file doesn't confirm with some standards used by BibTeX mode,
some of the high-level features of BibTeX mode won't be available.
This function tries to convert current buffer to confirm with these standards.
With prefix argument DO-ADDITIONAL-REFORMATTING
non-nil, read options for reformatting entries from minibuffer." nil [154393 155652]) ("bibtex-complete-string" function nil nil ((user-visible . t)) "Complete word fragment before point to longest prefix of a defined string.
If point is not after the part of a word, all strings are listed.
Remove surrounding delimiters if complete string could be expanded." nil [155654 155957]) ("bibtex-complete-key" function nil nil ((user-visible . t)) "Complete word fragment before point to longest prefix of a defined key.
If point is not after the part of a word, all keys are listed.  This
function is most useful in completing crossref entries." nil [155959 156319]) ("bibtex-Article" function nil nil ((user-visible . t)) "Insert a new BibTeX @Article entry; see also `bibtex-entry'." nil [156321 156454]) ("bibtex-Book" function nil nil ((user-visible . t)) "Insert a new BibTeX @Book entry; see also `bibtex-entry'." nil [156456 156580]) ("bibtex-Booklet" function nil nil ((user-visible . t)) "Insert a new BibTeX @Booklet entry; see also `bibtex-entry'." nil [156582 156715]) ("bibtex-InBook" function nil nil ((user-visible . t)) "Insert a new BibTeX @InBook entry; see also `bibtex-entry'." nil [156717 156847]) ("bibtex-InCollection" function nil nil ((user-visible . t)) "Insert a new BibTeX @InCollection entry; see also `bibtex-entry'." nil [156849 156997]) ("bibtex-InProceedings" function nil nil ((user-visible . t)) "Insert a new BibTeX @InProceedings entry; see also `bibtex-entry'." nil [156999 157150]) ("bibtex-Manual" function nil nil ((user-visible . t)) "Insert a new BibTeX @Manual entry; see also `bibtex-entry'." nil [157152 157282]) ("bibtex-MastersThesis" function nil nil ((user-visible . t)) "Insert a new BibTeX @MastersThesis entry; see also `bibtex-entry'." nil [157284 157435]) ("bibtex-Misc" function nil nil ((user-visible . t)) "Insert a new BibTeX @Misc entry; see also `bibtex-entry'." nil [157437 157561]) ("bibtex-PhdThesis" function nil nil ((user-visible . t)) "Insert a new BibTeX @PhdThesis entry; see also `bibtex-entry'." nil [157563 157702]) ("bibtex-Proceedings" function nil nil ((user-visible . t)) "Insert a new BibTeX @Proceedings entry; see also `bibtex-entry'." nil [157704 157849]) ("bibtex-TechReport" function nil nil ((user-visible . t)) "Insert a new BibTeX @TechReport entry; see also `bibtex-entry'." nil [157851 157993]) ("bibtex-Unpublished" function nil nil ((user-visible . t)) "Insert a new BibTeX @Unpublished entry; see also `bibtex-entry'." nil [157995 158140]) ("bibtex-String" function nil nil ((user-visible . t)) "Insert a new BibTeX @String entry." nil [158142 159314]) ("bibtex-Preamble" function nil nil ((user-visible . t)) "Insert a new BibTeX @Preamble entry." nil [159316 159614]) ("bibtex" package nil nil nil [159644 159661]))
    )
   (semanticdb-table "sgml-mode.el"
    :file "sgml-mode.el"
    :pointmax 53076
    :major-mode 'emacs-lisp-mode
    :tokens '(("eval-when-compile" code nil [1291 1353]) ("defgroup" code nil [1355 1416]) ("sgml-transformation" variable nil (quote identity) ((user-visible . t)) "*Default value for `skeleton-transformation' (which see) in SGML mode." nil [1418 1567]) ("put" code nil [1569 1651]) ("sgml-mode-hook" variable nil nil nil "Hook run by command `sgml-mode'.
`text-mode-hook' is run first." nil [1653 1780]) ("sgml-specials" variable nil (quote (34)) nil "List of characters that have a special meaning for SGML mode.
This list is used when first loading the sgml-mode library.
The supported characters and potential disadvantages are:

  ?\\\"	Makes \" in text start a string.
  ?'	Makes ' in text start a string.
  ?-	Makes -- in text start a comment.

When only one of ?\\\" or ?' are included, \"'\" or '\"', as can be found in
DTDs, start a string.  To partially avoid this problem this also makes these
self insert as named entities depending on `sgml-quick-keys'.

Including ?- has the problem of affecting dashes that have nothing to do
with comments, so we normally turn it off." nil [1962 2627]) ("sgml-quick-keys" variable nil nil nil "Use <, >, &, SPC and `sgml-specials' keys \"electrically\" when non-nil.
This takes effect when first loading the sgml-mode library." nil [2629 2794]) ("sgml-mode-map" variable nil (let ((map (make-keymap)) (menu-map (make-sparse-keymap "SGML"))) (define-key map "	" (quote sgml-tags-invisible)) (define-key map "/" (quote sgml-slash)) (define-key map "" (quote sgml-name-char)) (define-key map "" (quote sgml-tag)) (define-key map "" (quote sgml-attributes)) (define-key map "" (quote sgml-skip-tag-backward)) (define-key map [3 left] (quote sgml-skip-tag-backward)) (define-key map "" (quote sgml-skip-tag-forward)) (define-key map [3 right] (quote sgml-skip-tag-forward)) (define-key map "" (quote sgml-delete-tag)) (define-key map "" (quote sgml-delete-tag)) (define-key map "?" (quote sgml-tag-help)) (define-key map "8" (quote sgml-name-8bit-mode)) (define-key map "" (quote sgml-validate)) (if sgml-quick-keys (progn (define-key map "&" (quote sgml-name-char)) (define-key map "<" (quote sgml-tag)) (define-key map " " (quote sgml-auto-attributes)) (define-key map ">" (quote sgml-maybe-end-tag)) (if (memq 34 sgml-specials) (define-key map "\"" (quote sgml-name-self))) (if (memq 39 sgml-specials) (define-key map "'" (quote sgml-name-self))))) (define-key map (vector (make-char (quote latin-iso8859-1))) (quote sgml-maybe-name-self)) (let ((c 127) (map (nth 1 map))) (while (< (setq c (1+ c)) 256) (aset map c (quote sgml-maybe-name-self)))) (define-key map [menu-bar sgml] (cons "SGML" menu-map)) (define-key menu-map [sgml-validate] (quote ("Validate" . sgml-validate))) (define-key menu-map [sgml-name-8bit-mode] (quote ("Toggle 8 Bit Insertion" . sgml-name-8bit-mode))) (define-key menu-map [sgml-tags-invisible] (quote ("Toggle Tag Visibility" . sgml-tags-invisible))) (define-key menu-map [sgml-tag-help] (quote ("Describe Tag" . sgml-tag-help))) (define-key menu-map [sgml-delete-tag] (quote ("Delete Tag" . sgml-delete-tag))) (define-key menu-map [sgml-skip-tag-forward] (quote ("Forward Tag" . sgml-skip-tag-forward))) (define-key menu-map [sgml-skip-tag-backward] (quote ("Backward Tag" . sgml-skip-tag-backward))) (define-key menu-map [sgml-attributes] (quote ("Insert Attributes" . sgml-attributes))) (define-key menu-map [sgml-tag] (quote ("Insert Tag" . sgml-tag))) map) nil "Keymap for SGML mode.  See also `sgml-specials'." nil [2797 5100]) ("sgml-mode-syntax-table" variable nil (let ((table (copy-syntax-table text-mode-syntax-table))) (modify-syntax-entry 60 "(>" table) (modify-syntax-entry 62 ")<" table) (if (memq 45 sgml-specials) (modify-syntax-entry 45 "_ 1234" table)) (if (memq 34 sgml-specials) (modify-syntax-entry 34 "\"\"" table)) (if (memq 39 sgml-specials) (modify-syntax-entry 39 "\"'" table)) table) nil "Syntax table used in SGML mode.  See also `sgml-specials'." nil [5103 5568]) ("sgml-name-8bit-mode" variable nil nil ((user-visible . t)) "*When non-nil, insert non-ASCII characters as named entities." nil [5571 5704]) ("sgml-char-names" variable nil [nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil "nbsp" "excl" "quot" "num" "dollar" "percnt" "amp" "apos" "lpar" "rpar" "ast" "plus" "comma" "hyphen" "period" "sol" nil nil nil nil nil nil nil nil nil nil "colon" "semi" "lt" "eq" "gt" "quest" "commat" nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil "lsqb" nil "rsqb" "uarr" "lowbar" "lsquo" nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil "lcub" "verbar" "rcub" "tilde" nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil "nbsp" "iexcl" "cent" "pound" "curren" "yen" "brvbar" "sect" "uml" "copy" "ordf" "laquo" "not" "shy" "reg" "macr" "ring" "plusmn" "sup2" "sup3" "acute" "micro" "para" "middot" "cedil" "sup1" "ordm" "raquo" "frac14" "frac12" "frac34" "iquest" "Agrave" "Aacute" "Acirc" "Atilde" "Auml" "Aring" "AElig" "Ccedil" "Egrave" "Eacute" "Ecirc" "Euml" "Igrave" "Iacute" "Icirc" "Iuml" "ETH" "Ntilde" "Ograve" "Oacute" "Ocirc" "Otilde" "Ouml" nil "Oslash" "Ugrave" "Uacute" "Ucirc" "Uuml" "Yacute" "THORN" "szlig" "agrave" "aacute" "acirc" "atilde" "auml" "aring" "aelig" "ccedil" "egrave" "eacute" "ecirc" "euml" "igrave" "iacute" "icirc" "iuml" "eth" "ntilde" "ograve" "oacute" "ocirc" "otilde" "ouml" "divide" "oslash" "ugrave" "uacute" "ucirc" "uuml" "yacute" "thorn" "yuml"] nil "Vector of symbolic character names without `&' and `;'." nil [5706 7400]) ("put" code nil [7402 7445]) ("sgml-char-names-table" variable nil (let ((table (make-char-table (quote sgml-table))) (i 32) elt) (while (< i 256) (setq elt (aref sgml-char-names i)) (if elt (aset table (make-char (quote latin-iso8859-1) i) elt)) (setq i (1+ i))) table) nil "A table for mapping non-ASCII characters into SGML entity names.
Currently, only Latin-1 characters are supported." nil [7447 7816]) ("sgml-validate-command" variable nil "nsgmls -s" ((user-visible . t)) "*The command to validate an SGML document.
The file name of current buffer file name will be appended to this,
separated by a space." nil [8028 8282]) ("sgml-saved-validate-command" variable nil nil nil "The command last used to validate in this buffer." nil [8284 8378]) ("sgml-slash-distance" variable nil 1000 ((user-visible . t)) "*If non-nil, is the maximum distance to search for matching `/'." nil [8478 8636]) ("sgml-start-tag-regex" variable nil "<[[:alnum:]]\\([-_.:[:alnum:]= 
	]\\|\"[^\"]*\"\\|'[^']*'\\)*" ((const . t)) "Regular expression that matches a non-empty start tag.
Any terminating `>' or `/' is not matched." nil [8638 8839]) ("sgml-font-lock-keywords-1" variable nil (quote (("<\\([!?][[:alnum:]][-_.:[:alnum:]]*\\)" 1 font-lock-keyword-face) ("<\\(/?[[:alnum:]][-_.:[:alnum:]]*\\)" 1 font-lock-function-name-face) ("[&%][[:alpha:]][-_.:[:alnum:]]*;?" . font-lock-variable-name-face))) ((const . t)) nil nil [8854 9112]) ("sgml-font-lock-keywords-2" variable nil nil ((const . t)) nil nil [9114 9153]) ("sgml-font-lock-keywords" variable nil sgml-font-lock-keywords-1 ((user-visible . t)) "*Rules for highlighting SGML code.  See also `sgml-tag-face-alist'." nil [9266 9396]) ("sgml-face-tag-alist" variable nil nil nil "Alist of face and tag name for facemenu." nil [9410 9486]) ("sgml-tag-face-alist" variable nil nil nil "Tag names and face or list of faces to fontify with when invisible.
When `font-lock-maximum-decoration' is 1 this is always used for fontifying.
When more these are fontified together with `sgml-font-lock-keywords'." nil [9488 9739]) ("sgml-display-text" variable nil nil nil "Tag names as lowercase symbols, and display string when invisible." nil [9742 9842]) ("sgml-tags-invisible" variable nil nil nil nil nil [9856 9888]) ("sgml-tag-alist" variable nil (quote (("![" ("ignore" t) ("include" t)) ("!attlist") ("!doctype") ("!element") ("!entity"))) ((user-visible . t)) "*Alist of tag names for completing read and insertion rules.
This alist is made up as

  ((\"tag\" . TAGRULE)
   ...)

TAGRULE is a list of optionally `t' (no endtag) or `\\n' (separate endtag by
newlines) or a skeleton with `nil', `t' or `\\n' in place of the interactor
followed by an ATTRIBUTERULE (for an always present attribute) or an
attribute alist.

The attribute alist is made up as

  ((\"attribute\" . ATTRIBUTERULE)
   ...)

ATTRIBUTERULE is a list of optionally `t' (no value when no input) followed by
an optional alist of possible values." nil [9891 10686]) ("sgml-tag-help" variable nil (quote (("!" . "Empty declaration for comment") ("![" . "Embed declarations with parser directive") ("!attlist" . "Tag attributes declaration") ("!doctype" . "Document type (DTD) declaration") ("!element" . "Tag declaration") ("!entity" . "Entity (macro) declaration"))) ((user-visible . t)) "*Alist of tag name and short description." nil [10688 11147]) ("v2" variable nil nil nil nil nil [11149 11160]) ("sgml-mode-common" function nil ("sgml-tag-face-alist" "sgml-display-text") nil "Common code for setting up `sgml-mode' and derived modes.
SGML-TAG-FACE-ALIST is used for calculating `sgml-font-lock-keywords-2'.
SGML-DISPLAY-TEXT sets up alternate text for when tags are invisible (see
varables of same name)." nil [11185 14389]) ("sgml-mode-facemenu-add-face-function" function nil ("face" "end") nil (if (setq face (cdr (assq face sgml-face-tag-alist))) (progn (setq face (funcall skeleton-transformation face)) (setq facemenu-end-add-face (concat "</" face ">")) (concat "<" face ">")) (error "Face not configured for %s mode" mode-name)) nil [14392 14702]) ("sgml-mode" function nil nil ((user-visible . t)) "Major mode for editing SGML documents.
Makes > match <.  Makes / blink matching /.
Keys <, &, SPC within <>, \" and ' can be electric depending on
`sgml-quick-keys'.

An argument of N to a tag-inserting command means to wrap it around
the next N words.  In Transient Mark mode, when the mark is active,
N defaults to -1, which means to wrap it around the current region.

If you like upcased tags, put (setq sgml-transformation 'upcase) in
your `.emacs' file.

Use \\[sgml-validate] to validate your document with an SGML parser.

Do \\[describe-variable] sgml- SPC to see available variables.
Do \\[describe-key] on the following bindings to discover what they do.
\\{sgml-mode-map}" nil [14720 15956]) ("sgml-comment-indent" function nil nil nil (if (looking-at "--") comment-column 0) nil [15959 16031]) ("sgml-slash" function nil ("arg") ((user-visible . t)) "Insert `/' and display any previous matching `/'.
Two `/'s are treated as matching if the first `/' ends a net-enabling
start tag, and the second `/' is the corresponding null end tag." nil [16035 17281]) ("sgml-name-char" function nil ("&optional" "char") ((user-visible . t)) "Insert a symbolic character name according to `sgml-char-names'.
Non-ASCII chars may be inserted either with the meta key, as in M-SPC for
no-break space or M-- for a soft hyphen; or via an input method or
encoded keyboard operation." nil [17491 18319]) ("sgml-name-self" function nil nil ((user-visible . t)) "Insert a symbolic character name according to `sgml-char-names'." nil [18321 18472]) ("sgml-maybe-name-self" function nil nil ((user-visible . t)) "Insert a symbolic character name according to `sgml-char-names'." nil [18474 18807]) ("sgml-name-8bit-mode" function nil nil ((user-visible . t)) "Toggle whether to insert named entities instead of non-ASCII characters.
This only works for Latin-1 input." nil [18864 19163]) ("define-skeleton" code nil [19405 20433]) ("skeleton-read" function nil nil ((prototype . t)) nil nil [20435 20471]) ("sgml-attributes" function nil ("tag" "&optional" "quiet") ((user-visible . t)) "When at top level of a tag, interactively insert attributes.

Completion and configuration of TAG are done according to `sgml-tag-alist'.
If QUIET, do not print a message when there are no attributes for TAG." nil [20473 21746]) ("sgml-auto-attributes" function nil ("arg") ((user-visible . t)) "Self insert the character typed; at top level of tag, prompt for attributes.
With prefix argument, only self insert." nil [21748 22299]) ("sgml-tag-help" function nil ("&optional" "tag") ((user-visible . t)) "Display description of tag TAG.  If TAG is omitted, use the tag at point." nil [22302 22837]) ("sgml-maybe-end-tag" function nil nil ((user-visible . t)) "Name self unless in position to end a tag." nil [22840 23152]) ("sgml-skip-tag-backward" function nil ("arg") ((user-visible . t)) "Skip to beginning of tag or matching opening tag if present.
With prefix argument ARG, repeat this ARG times." nil [23155 23712]) ("sgml-skip-tag-forward" function nil ("arg" "&optional" "return") ((user-visible . t)) "Skip to end of tag or matching closing tag if present.
With prefix argument ARG, repeat this ARG times.
Return t iff after a closing tag." nil [23714 24639]) ("sgml-delete-tag" function nil ("arg") ((user-visible . t)) "Delete tag on or after cursor, and matching closing or opening tag.
With prefix argument ARG, repeat this ARG times." nil [24641 25811]) ("or" code nil [25888 26095]) ("sgml-tags-invisible" function nil ("arg") ((user-visible . t)) "Toggle visibility of existing tags." nil [26097 27459]) ("sgml-point-entered" function nil ("x" "y") nil (let ((inhibit-point-motion-hooks t)) (save-excursion (message "Invisible tag: %s" (buffer-substring-no-properties (point) (if (or (and (> x y) (not (eq (following-char) 60))) (and (< x y) (eq (preceding-char) 62))) (backward-list) (forward-list)))))) nil [27461 27937]) ("compile-internal" function nil nil ((prototype . t)) nil nil [27940 27978]) ("sgml-validate" function nil ("command") ((user-visible . t)) "Validate an SGML document.
Runs COMMAND, a shell command, in a separate process asynchronously
with output going to the buffer `*compilation*'.
You can then use the command \\[next-error] to find the next error message
and move to the line in the SGML document that caused it." nil [27980 28685]) ("sgml-beginning-of-tag" function nil ("&optional" "top-level") nil "Skip to beginning of tag and return its name.
If this can't be done, return t." nil [28688 29143]) ("sgml-value" function nil ("alist") nil "Interactively insert value taken from attributerule ALIST.
See `sgml-tag-alist' for info about attributerules.." nil [29145 29747]) ("html-mode-hook" variable nil nil nil "Hook run by command `html-mode'.
`text-mode-hook' and `sgml-mode-hook' are run first." nil [29766 29948]) ("html-quick-keys" variable nil sgml-quick-keys nil "Use C-c X combinations for quick insertion of frequent tags when non-nil.
This defaults to `sgml-quick-keys'.
This takes effect when first loading the library." nil [29950 30154]) ("html-mode-map" variable nil (let ((map (make-sparse-keymap)) (menu-map (make-sparse-keymap "HTML"))) (set-keymap-parent map sgml-mode-map) (define-key map "6" (quote html-headline-6)) (define-key map "5" (quote html-headline-5)) (define-key map "4" (quote html-headline-4)) (define-key map "3" (quote html-headline-3)) (define-key map "2" (quote html-headline-2)) (define-key map "1" (quote html-headline-1)) (define-key map ">" (quote html-entity-gt)) (define-key map "<" (quote html-entity-lt)) (define-key map "" (quote html-paragraph)) (define-key map "b" (quote html-line)) (define-key map "-" (quote html-horizontal-rule)) (define-key map "o" (quote html-ordered-list)) (define-key map "u" (quote html-unordered-list)) (define-key map "r" (quote html-radio-buttons)) (define-key map "c" (quote html-checkboxes)) (define-key map "l" (quote html-list-item)) (define-key map "h" (quote html-href-anchor)) (define-key map "n" (quote html-name-anchor)) (define-key map "i" (quote html-image)) (define-key map "e" (quote html-emphasis)) (define-key map "b" (quote html-bold)) (define-key map "t" (quote html-typewriter)) (define-key map "c" (quote html-code)) (if html-quick-keys (progn (define-key map "<" (quote sgml-tag)) (define-key map ">" (quote sgml-maybe-end-tag)) (define-key map "-" (quote html-horizontal-rule)) (define-key map "o" (quote html-ordered-list)) (define-key map "u" (quote html-unordered-list)) (define-key map "r" (quote html-radio-buttons)) (define-key map "c" (quote html-checkboxes)) (define-key map "l" (quote html-list-item)) (define-key map "h" (quote html-href-anchor)) (define-key map "n" (quote html-name-anchor)) (define-key map "i" (quote html-image)))) (define-key map "" (quote html-autoview-mode)) (define-key map "" (quote browse-url-of-buffer)) (define-key map [menu-bar html] (cons "HTML" menu-map)) (define-key menu-map [html-autoview-mode] (quote ("Toggle Autoviewing" . html-autoview-mode))) (define-key menu-map [browse-url-of-buffer] (quote ("View Buffer Contents" . browse-url-of-buffer))) (define-key menu-map [nil] (quote ("--"))) (define-key menu-map "3" (quote ("Heading 3" . html-headline-3))) (define-key menu-map "2" (quote ("Heading 2" . html-headline-2))) (define-key menu-map "1" (quote ("Heading 1" . html-headline-1))) (define-key menu-map "l" (quote ("Radio Buttons" . html-radio-buttons))) (define-key menu-map "c" (quote ("Checkboxes" . html-checkboxes))) (define-key menu-map "l" (quote ("List Item" . html-list-item))) (define-key menu-map "u" (quote ("Unordered List" . html-unordered-list))) (define-key menu-map "o" (quote ("Ordered List" . html-ordered-list))) (define-key menu-map "-" (quote ("Horizontal Rule" . html-horizontal-rule))) (define-key menu-map "
" (quote ("Line Break" . html-line))) (define-key menu-map "" (quote ("Paragraph" . html-paragraph))) (define-key menu-map "i" (quote ("Image" . html-image))) (define-key menu-map "h" (quote ("Href Anchor" . html-href-anchor))) (define-key menu-map "n" (quote ("Name Anchor" . html-name-anchor))) map) nil "Keymap for commands for use in HTML mode." nil [30156 33487]) ("html-face-tag-alist" variable nil (quote ((bold . "b") (italic . "i") (underline . "u") (modeline . "rev"))) nil "Value of `sgml-face-tag-alist' for HTML mode." nil [33490 33650]) ("html-tag-face-alist" variable nil (quote (("b" . bold) ("big" . bold) ("blink" . highlight) ("cite" . italic) ("em" . italic) ("h1" bold underline) ("h2" bold-italic underline) ("h3" italic underline) ("h4" . underline) ("h5" . underline) ("h6" . underline) ("i" . italic) ("rev" . modeline) ("s" . underline) ("small" . default) ("strong" . bold) ("title" bold underline) ("tt" . default) ("u" . underline) ("var" . italic))) nil "Value of `sgml-tag-face-alist' for HTML mode." nil [33652 34195]) ("html-display-text" variable nil (quote ((img . "[/]") (hr . "----------") (li . "o "))) nil "Value of `sgml-display-text' for HTML mode." nil [34198 34331]) ("html-tag-alist" variable nil (let* ((1-7 (quote (("1") ("2") ("3") ("4") ("5") ("6") ("7")))) (1-9 (\` ((\,@ 1-7) ("8") ("9")))) (align (quote (("align" ("left") ("center") ("right"))))) (valign (quote (("top") ("middle") ("bottom") ("baseline")))) (rel (quote (("next") ("previous") ("parent") ("subdocument") ("made")))) (href (quote ("href" ("ftp:") ("file:") ("finger:") ("gopher:") ("http:") ("mailto:") ("news:") ("rlogin:") ("telnet:") ("tn3270:") ("wais:") ("/cgi-bin/")))) (name (quote ("name"))) (link (\` ((\, href) ("rel" (\,@ rel)) ("rev" (\,@ rel)) ("title")))) (list (quote ((nil n ("List item: " "<li>" str n))))) (cell (\` (t (\,@ align) ("valign" (\,@ valign)) ("colspan" (\,@ 1-9)) ("rowspan" (\,@ 1-9)) ("nowrap" t))))) (\` (("a" (\, name) (\,@ link)) ("base" t (\,@ href)) ("dir" (\,@ list)) ("font" nil "size" ("-1") ("+1") ("-2") ("+2") (\,@ 1-7)) ("form" (n _ n "<input type=\"submit\" value=\"\">") ("action" (\,@ (cdr href))) ("method" ("get") ("post"))) ("h1" (\,@ align)) ("h2" (\,@ align)) ("h3" (\,@ align)) ("h4" (\,@ align)) ("h5" (\,@ align)) ("h6" (\,@ align)) ("hr" t ("size" (\,@ 1-9)) ("width") ("noshade" t) (\,@ align)) ("img" t ("align" (\,@ valign) ("texttop") ("absmiddle") ("absbottom")) ("src") ("alt") ("width" "1") ("height" "1") ("border" "1") ("vspace" "1") ("hspace" "1") ("ismap" t)) ("input" t ("size" (\,@ 1-9)) ("maxlength" (\,@ 1-9)) ("checked" t) (\, name) ("type" ("text") ("password") ("checkbox") ("radio") ("submit") ("reset")) ("value")) ("link" t (\,@ link)) ("menu" (\,@ list)) ("ol" (\,@ list) ("type" ("A") ("a") ("I") ("i") ("1"))) ("p" t (\,@ align)) ("select" (nil n ("Text: " "<option>" str n)) (\, name) ("size" (\,@ 1-9)) ("multiple" t)) ("table" (nil n ((completing-read "Cell kind: " (quote (("td") ("th"))) nil t "t") "<tr><" str 62 _ n)) ("border" t (\,@ 1-9)) ("width" "10") ("cellpadding")) ("td" (\,@ cell)) ("textarea" (\, name) ("rows" (\,@ 1-9)) ("cols" (\,@ 1-9))) ("th" (\,@ cell)) ("ul" (\,@ list) ("type" ("disc") ("circle") ("square"))) (\,@ sgml-tag-alist) ("abbrev") ("acronym") ("address") ("array" (nil n ("Item: " "<item>" str n)) "align") ("au") ("b") ("big") ("blink") ("blockquote" n) ("body" n ("background" ".gif") ("bgcolor" "#") ("text" "#") ("link" "#") ("alink" "#") ("vlink" "#")) ("box" (nil _ "<over>" _)) ("br" t ("clear" ("left") ("right"))) ("caption" ("valign" ("top") ("bottom"))) ("center" n) ("cite") ("code" n) ("dd" t) ("del") ("dfn") ("div") ("dl" (nil n ("Term: " "<dt>" str "<dd>" _ n))) ("dt" (t _ "<dd>")) ("em") ("head" n) ("html" (n "<head>
" "<title>" (setq str (read-input "Title: ")) "</title>
" "</head>
" "<body>
<h1>" str "</h1>
" _ "
<address>
<a href=\"mailto:" user-mail-address "\">" (user-full-name) "</a>
</address>
" "</body>")) ("i") ("ins") ("isindex" t ("action") ("prompt")) ("kbd") ("lang") ("li" t) ("math" n) ("nobr") ("option" t ("value") ("label") ("selected" t)) ("over" t) ("person") ("pre" n) ("q") ("rev") ("s") ("samp") ("small") ("span") ("strong") ("sub") ("sup") ("title") ("tr" t) ("tt") ("u") ("var") ("wbr" t)))) ((user-visible . t)) "*Value of `sgml-tag-alist' for HTML mode." nil [34391 38139]) ("html-tag-help" variable nil (\` ((\,@ sgml-tag-help) ("a" . "Anchor of point or link elsewhere") ("abbrev" . "?") ("acronym" . "?") ("address" . "Formatted mail address") ("array" . "Math array") ("au" . "?") ("b" . "Bold face") ("base" . "Base address for URLs") ("big" . "Font size") ("blink" . "Blinking text") ("blockquote" . "Indented quotation") ("body" . "Document body") ("box" . "Math fraction") ("br" . "Line break") ("caption" . "Table caption") ("center" . "Centered text") ("changed" . "Change bars") ("cite" . "Citation of a document") ("code" . "Formatted source code") ("dd" . "Definition of term") ("del" . "?") ("dfn" . "?") ("dir" . "Directory list (obsolete)") ("dl" . "Definition list") ("dt" . "Term to be definined") ("em" . "Emphasised") ("embed" . "Embedded data in foreign format") ("fig" . "Figure") ("figa" . "Figure anchor") ("figd" . "Figure description") ("figt" . "Figure text") ("font" . "Font size") ("form" . "Form with input fields") ("group" . "Document grouping") ("h1" . "Most important section headline") ("h2" . "Important section headline") ("h3" . "Section headline") ("h4" . "Minor section headline") ("h5" . "Unimportant section headline") ("h6" . "Least important section headline") ("head" . "Document header") ("hr" . "Horizontal rule") ("html" . "HTML Document") ("i" . "Italic face") ("img" . "Graphic image") ("input" . "Form input field") ("ins" . "?") ("isindex" . "Input field for index search") ("kbd" . "Keybard example face") ("lang" . "Natural language") ("li" . "List item") ("link" . "Link relationship") ("math" . "Math formula") ("menu" . "Menu list (obsolete)") ("mh" . "Form mail header") ("nextid" . "Allocate new id") ("nobr" . "Text without line break") ("ol" . "Ordered list") ("option" . "Selection list item") ("over" . "Math fraction rule") ("p" . "Paragraph start") ("panel" . "Floating panel") ("person" . "?") ("pre" . "Preformatted fixed width text") ("q" . "?") ("rev" . "Reverse video") ("s" . "?") ("samp" . "Sample text") ("select" . "Selection list") ("small" . "Font size") ("sp" . "Nobreak space") ("strong" . "Standout text") ("sub" . "Subscript") ("sup" . "Superscript") ("table" . "Table with rows and columns") ("tb" . "Table vertical break") ("td" . "Table data cell") ("textarea" . "Form multiline edit area") ("th" . "Table header cell") ("title" . "Document title") ("tr" . "Table row separator") ("tt" . "Typewriter face") ("u" . "Underlined text") ("ul" . "Unordered list") ("var" . "Math variable face") ("wbr" . "Enable <br> within <nobr>"))) ((user-visible . t)) "*Value of `sgml-tag-help' for HTML mode." nil [38141 41079]) ("html-mode" function nil nil ((user-visible . t)) "Major mode based on SGML mode for editing HTML documents.
This allows inserting skeleton constructs used in hypertext documents with
completion.  See below for an introduction to HTML.  Use
\\[browse-url-of-buffer] to see how this comes out.  See also `sgml-mode' on
which this is based.

Do \\[describe-variable] html- SPC and \\[describe-variable] sgml- SPC to see available variables.

To write fairly well formatted pages you only need to know few things.  Most
browsers have a function to read the source code of the page being seen, so
you can imitate various tricks.  Here's a very short HTML primer which you
can also view with a browser to see what happens:

<title>A Title Describing Contents</title> should be on every page.  Pages can
have <h1>Very Major Headlines</h1> through <h6>Very Minor Headlines</h6>
<hr> Parts can be separated with horizontal rules.

<p>Paragraphs only need an opening tag.  Line breaks and multiple spaces are
ignored unless the text is <pre>preformatted.</pre>  Text can be marked as
<b>bold</b>, <i>italic</i> or <u>underlined</u> using the normal  M-g  or
Edit/Text Properties/Face commands.

Pages can have <a name=\"SOMENAME\">named points</a> and can link other points
to them with <a href=\"#SOMENAME\">see also somename</a>.  In the same way <a
href=\"URL\">see also URL</a> where URL is a filename relative to current
directory, or absolute as in `http://www.cs.indiana.edu/elisp/w3/docs.html'.

Images in many formats can be inlined with <img src=\"URL\">.

If you mainly create your own documents, `sgml-specials' might be
interesting.  But note that some HTML 2 browsers can't handle `&apos;'.
To work around that, do:
   (eval-after-load \"sgml-mode\" '(aset sgml-char-names ?' nil))

\\{html-mode-map}" nil [41097 44098]) ("html-imenu-regexp" variable nil "\\s-*<h\\([1-9]\\)[^
<>]*>\\(<[^
<>]*>\\)*\\s-*\\([^
<>]*\\)" ((user-visible . t)) "*A regular expression matching a head line to be added to the menu.
The first `match-string' should be a number from 1-9.
The second `match-string' matches extra tags and is ignored.
The third `match-string' will be the used in the menu." nil [44101 44437]) ("html-imenu-index" function nil nil nil "Return an table of contents for an HTML buffer for use with Imenu." nil [44439 44907]) ("html-autoview-mode" function nil ("&optional" "arg") ((user-visible . t)) "Toggle automatic viewing via `browse-url-of-buffer' upon saving buffer.
With positive prefix ARG always turns viewing on, with negative ARG always off.
Can be used as a value for `html-mode-hook'." nil [44909 45523]) ("define-skeleton" code nil [45526 45664]) ("define-skeleton" code nil [45666 45786]) ("define-skeleton" code nil [45788 45878]) ("define-skeleton" code nil [45880 45970]) ("define-skeleton" code nil [45972 46062]) ("define-skeleton" code nil [46064 46154]) ("define-skeleton" code nil [46156 46246]) ("define-skeleton" code nil [46248 46338]) ("define-skeleton" code nil [46340 46426]) ("define-skeleton" code nil [46428 46751]) ("define-skeleton" code nil [46753 46824]) ("define-skeleton" code nil [46826 46939]) ("define-skeleton" code nil [46941 47060]) ("define-skeleton" code nil [47062 47173]) ("define-skeleton" code nil [47175 47292]) ("define-skeleton" code nil [47294 47374]) ("define-skeleton" code nil [47376 47446]) ("define-skeleton" code nil [47448 47532]) ("define-skeleton" code nil [47535 47611]) ("define-skeleton" code nil [47615 48172]) ("define-skeleton" code nil [48174 48788]) ("define-skeleton" code nil [48790 48864]) ("define-skeleton" code nil [48866 48940]) ("define-skeleton" code nil [48942 49109]) ("define-skeleton" code nil [49111 49278]) ("define-skeleton" code nil [49280 49448]) ("define-skeleton" code nil [49450 49603]) ("define-skeleton" code nil [49605 49765]) ("define-skeleton" code nil [49767 50081]) ("define-skeleton" code nil [50083 50270]) ("define-skeleton" code nil [50273 50678]) ("define-skeleton" code nil [50680 50859]) ("define-skeleton" code nil [50863 51532]) ("define-skeleton" code nil [51534 53022]) ("sgml-mode" package nil nil nil [53026 53046]))
    :unmatched-syntax 'nil
    )
   (semanticdb-table "flyspell.el"
    :file "flyspell.el"
    :pointmax 100038
    :major-mode 'emacs-lisp-mode
    :tokens '(("ispell" include nil nil nil [1737 1754]) ("defgroup" code nil [1978 2109]) ("flyspell-emacs" variable nil (cond ((string-match "XEmacs" emacs-version) (quote xemacs)) (t (quote emacs))) nil "The type of Emacs we are currently running." nil [2333 2486]) ("flyspell-use-local-map" variable nil (or (eq flyspell-emacs (quote xemacs)) (not (string< emacs-version "20"))) nil nil nil [2488 2595]) ("flyspell-highlight-flag" variable nil t ((user-visible . t)) "*How Flyspell should indicate misspelled words.
Non-nil means use highlight, nil means use minibuffer messages." nil [2819 3008]) ("flyspell-mark-duplications-flag" variable nil t ((user-visible . t)) "*Non-nil means Flyspell reports a repeated word as an error." nil [3010 3156]) ("flyspell-sort-corrections" variable nil nil ((user-visible . t)) "*Non-nil means, sort the corrections alphabetically before popping them." nil [3158 3330]) ("flyspell-duplicate-distance" variable nil -1 ((user-visible . t)) "*The maximum distance for finding duplicates of unrecognized words.
This applies to the feature that when a word is not found in the dictionary,
if the same spelling occurs elsewhere in the buffer,
Flyspell uses a different face (`flyspell-duplicate-face') to highlight it.
This variable specifies how far to search to find such a duplicate.
-1 means no limit (search the whole buffer).
0 means do not search for duplicate unrecognized spellings." nil [3332 3878]) ("flyspell-delay" variable nil 3 ((user-visible . t)) "*The number of seconds to wait before checking, after a \"delayed\" command." nil [3880 4024]) ("flyspell-persistent-highlight" variable nil t ((user-visible . t)) "*Non-nil means misspelled words remain highlighted until corrected.
If this variable is nil, only the most recently detected misspelled word
is highlighted." nil [4026 4266]) ("flyspell-highlight-properties" variable nil t ((user-visible . t)) "*Non-nil means highlight incorrect words even if a property exists for this word." nil [4268 4433]) ("flyspell-default-delayed-commands" variable nil (quote (self-insert-command delete-backward-char backward-or-forward-delete-char delete-char scrollbar-vertical-drag backward-delete-char-untabify)) nil "The standard list of delayed commands for Flyspell.
See `flyspell-delayed-commands'." nil [4435 4797]) ("flyspell-delayed-commands" variable nil nil nil "List of commands that are \"delayed\" for Flyspell mode.
After these commands, Flyspell checking is delayed for a short time,
whose length is specified by `flyspell-delay'." nil [4799 5063]) ("flyspell-default-deplacement-commands" variable nil (quote (next-line previous-line scroll-up scroll-down)) nil "The standard list of deplacement commands for Flyspell.
See `flyspell-deplacement-commands'." nil [5065 5338]) ("flyspell-default-ignored-commands" variable nil (quote (fill-paragraph)) nil "The standard list of ignored commands for Flyspell.
 See `flyspell-delayed-commands'." nil [5340 5559]) ("flyspell-ignored-commands" variable nil nil nil "List of commands that are \"ignored\" for Flyspell mode.
 The changes in the text made by these commands are ignored.  This list is meant for commands that change text in a way that does not affect individual words, such as `fill-paragraph'." nil [5563 5918]) ("flyspell-deplacement-commands" variable nil nil nil "List of commands that are \"deplacement\" for Flyspell mode.
After these commands, Flyspell checking is performed only if the previous
command was not the very same command." nil [5921 6208]) ("flyspell-issue-welcome-flag" variable nil t ((user-visible . t)) "*Non-nil means that Flyspell should display a welcome message when started." nil [6210 6367]) ("flyspell-issue-message-flag" variable nil t ((user-visible . t)) "*Non-nil means that Flyspell emits messages when checking words." nil [6369 6515]) ("flyspell-incorrect-hook" variable nil nil ((user-visible . t)) "*List of functions to be called when incorrect words are encountered.
Each function is given three arguments: the beginning and the end
of the incorrect region.  The third is either the symbol 'doublon' or the list
of possible corrections as returned by 'ispell-parse-output'.

If any of the functions return non-Nil, the word is not highlighted as
incorrect." nil [6517 6971]) ("flyspell-default-dictionary" variable nil nil nil "A string that is the name of the default dictionary.
This is passed to the `ispell-change-dictionary' when flyspell is started.
If the variable `ispell-local-dictionary' or `ispell-dictionary' is non-nil
when flyspell is started, the value of that variable is used instead
of `flyspell-default-dictionary' to select the default dictionary.
Otherwise, if `flyspell-default-dictionary' is nil, it means to use
Ispell's ultimate default dictionary." nil [6973 7555]) ("flyspell-tex-command-regexp" variable nil "\\(\\(begin\\|end\\)[ 	]*{\\|\\(cite[a-z*]*\\|label\\|ref\\|eqref\\|usepackage\\|documentclass\\)[ 	]*\\(\\[[^]]*\\]\\)?{[^{}]*\\)" nil "A string that is the regular expression that matches TeX commands." nil [7557 7857]) ("flyspell-check-tex-math-command" variable nil nil ((user-visible . t)) "*Non nil means check even inside TeX math environment.
TeX math environments are discovered by the TEXMATHP that implemented
inside the texmathp.el Emacs package.  That package may be found at:
http://strw.leidenuniv.nl/~dominik/Tools" nil [7859 8181]) ("flyspell-dictionaries-that-consider-dash-as-word-delimiter" variable nil (quote ("francais" "deutsch8" "norsk")) nil "List of dictionary names that consider `-' as word delimiter." nil [8183 8418]) ("flyspell-abbrev-p" variable nil nil ((user-visible . t)) "*If non-nil, add correction to abbreviation table." nil [8420 8564]) ("flyspell-use-global-abbrev-table-p" variable nil nil ((user-visible . t)) "*If non-nil, prefer global abbrev table to local abbrev table." nil [8566 8739]) ("flyspell-mode-line-string" variable nil " Fly" ((user-visible . t)) "*String displayed on the modeline when flyspell is active.
Set this to nil if you don't want a modeline indicator." nil [8758 8989]) ("flyspell-large-region" variable nil 1000 ((user-visible . t)) "*The threshold that determines if a region is small.
The `flyspell-region' function is invoked if the region is small, the
word are checked one after the other using regular flyspell check
means.  If the region is large, a new Ispell process is spawned to get
speed.

if flyspell-large-region is nil, regions are treated as small." nil [8991 9434]) ("flyspell-insert-function" variable nil (function insert) ((user-visible . t)) "*Function for inserting word by flyspell upon correction." nil [9436 9589]) ("flyspell-before-incorrect-word-string" variable nil nil nil "String used to indicate an incorrect word starting." nil [9591 9756]) ("flyspell-after-incorrect-word-string" variable nil nil nil "String used to indicate an incorrect word ending." nil [9758 9920]) ("flyspell-use-meta-tab" variable nil t ((user-visible . t)) "*Non-nil means that flyspell uses META-TAB to correct word." nil [9922 10057]) ("flyspell-auto-correct-binding" variable nil (cond ((eq flyspell-emacs (quote xemacs)) [(control \;)]) (t [67108923])) nil "The key binding for flyspell auto correction." nil [10059 10250]) ("flyspell-generic-check-word-p" variable nil nil nil "Function providing per-mode customization over which words are flyspelled.
Returns t to continue checking, nil otherwise.
Flyspell mode sets this variable to whatever is the `flyspell-mode-predicate'
property of the major mode name." nil [11050 11329]) ("make-variable-buffer-local" code nil [11330 11389]) ("put" code nil [11465 11533]) ("put" code nil [11534 11605]) ("mail-mode-flyspell-verify" function nil nil nil "This function is used for `flyspell-generic-check-word-p' in Mail mode." nil [11606 12359]) ("put" code nil [12435 12509]) ("texinfo-mode-flyspell-verify" function nil nil nil "This function is used for `flyspell-generic-check-word-p' in Texinfo mode." nil [12510 12696]) ("put" code nil [12772 12838]) ("tex-mode-flyspell-verify" function nil nil nil "This function is used for `flyspell-generic-check-word-p' in LaTeX mode." nil [12839 13316]) ("put" code nil [13392 13460]) ("put" code nil [13461 13529]) ("sgml-mode-flyspell-verify" function nil nil nil "This function is used for `flyspell-generic-check-word-p' in SGML mode." nil [13531 14277]) ("flyspell-prog-text-faces" variable nil (quote (font-lock-string-face font-lock-comment-face font-lock-doc-face)) nil "Faces corresponding to text in programming-mode buffers." nil [14501 14664]) ("flyspell-generic-progmode-verify" function nil nil nil "Used for `flyspell-generic-check-word-p' in programming modes." nil [14666 14862]) ("flyspell-prog-mode" function nil nil ((user-visible . t)) "Turn on `flyspell-mode' for comments and strings." nil [14879 15110]) ("make-overlay" function nil nil ((use-visible . t) (prototype . t)) "Overlay compatibility kit." nil [15334 15410]) ("overlayp" function nil nil ((use-visible . t) (prototype . t)) "Overlay compatibility kit." nil [15411 15487]) ("overlays-in" function nil nil ((use-visible . t) (prototype . t)) "Overlay compatibility kit." nil [15488 15564]) ("delete-overlay" function nil nil ((use-visible . t) (prototype . t)) "Overlay compatibility kit." nil [15565 15641]) ("overlays-at" function nil nil ((use-visible . t) (prototype . t)) "Overlay compatibility kit." nil [15642 15718]) ("overlay-put" function nil nil ((use-visible . t) (prototype . t)) "Overlay compatibility kit." nil [15719 15795]) ("overlay-get" function nil nil ((use-visible . t) (prototype . t)) "Overlay compatibility kit." nil [15796 15872]) ("previous-overlay-change" function nil nil ((use-visible . t) (prototype . t)) "Overlay compatibility kit." nil [15873 15949]) ("eval-when-compile" code nil [16173 16226]) ("flyspell-mode" variable nil nil nil nil nil [16243 16269]) ("make-variable-buffer-local" code nil [16270 16313]) ("flyspell-mouse-map" variable nil (let ((map (make-sparse-keymap))) (if flyspell-use-meta-tab (define-key map "\211" (function flyspell-auto-correct-word))) (define-key map (if (featurep (quote xemacs)) [button2] [down-mouse-2]) (function flyspell-correct-word)) (if (not (featurep (quote xemacs))) (define-key map [(shift down-mouse-2)] (function flyspell-correct-word))) (define-key map flyspell-auto-correct-binding (quote flyspell-auto-correct-previous-word)) (define-key map [(control \,)] (quote flyspell-goto-next-error)) (define-key map [(control \.)] (quote flyspell-auto-correct-word)) map) nil nil nil [16315 16886]) ("flyspell-mode-map" variable nil (make-sparse-keymap) nil nil nil [16903 16950]) ("when" code nil [17000 17836]) ("flyspell-overlay-keymap-property-name" variable nil (quote keymap) nil nil nil [17899 17953]) ("flyspell-consider-dash-as-word-delimiter-flag" variable nil nil ((user-visible . t)) "*Non-nil means that the `-' char is considered as a word delimiter." nil [17983 18114]) ("make-variable-buffer-local" code nil [18115 18190]) ("flyspell-dash-dictionary" variable nil nil nil nil nil [18191 18228]) ("make-variable-buffer-local" code nil [18229 18283]) ("flyspell-dash-local-dictionary" variable nil nil nil nil nil [18284 18327]) ("make-variable-buffer-local" code nil [18328 18388]) ("flyspell-incorrect-face" variable nil (if (eq flyspell-emacs (quote xemacs)) (quote ((((class color)) (:foreground "OrangeRed" :bold t :underline t)) (t (:bold t)))) (quote ((((class color)) (:foreground "OrangeRed" :weight bold :underline t)) (t (:weight bold))))) nil "Face used for marking a misspelled word in Flyspell." nil [18612 18947]) ("flyspell-duplicate-face" variable nil (if (eq flyspell-emacs (quote xemacs)) (quote ((((class color)) (:foreground "Gold3" :bold t :underline t)) (t (:bold t)))) (quote ((((class color)) (:foreground "Gold3" :weight bold :underline t)) (t (:weight bold))))) nil "Face used for marking a misspelled word that appears twice in the buffer.
See also `flyspell-duplicate-distance'." nil [18949 19337]) ("flyspell-overlay" variable nil nil nil nil nil [19339 19368]) ("flyspell-mode" function nil ("&optional" "arg") ((user-visible . t)) "Minor mode performing on-the-fly spelling checking.
Ispell is automatically spawned on background for each entered words.
The default flyspell behavior is to highlight incorrect words.
With no argument, this command toggles Flyspell mode.
With a prefix argument ARG, turn Flyspell minor mode on iff ARG is positive.
  
Bindings:
\\[ispell-word]: correct words (using Ispell).
\\[flyspell-auto-correct-word]: automatically correct word.
\\[flyspell-auto-correct-previous-word]: automatically correct the last misspelled word.
\\[flyspell-correct-word] (or down-mouse-2): popup correct words.

Hooks:
This runs `flyspell-mode-hook' after flyspell is entered.

Remark:
`flyspell-mode' uses `ispell-mode'.  Thus all Ispell options are
valid.  For instance, a personal dictionary can be used by
invoking `ispell-change-dictionary'.

Consider using the `ispell-parser' to check your text.  For instance
consider adding:
(add-hook 'tex-mode-hook (function (lambda () (setq ispell-parser 'tex))))
in your .emacs file.

\\[flyspell-region] checks all words inside a region.
\\[flyspell-buffer] checks the whole buffer." nil [19607 21192]) ("if" code nil [21431 21901]) ("flyspell-buffers" variable nil nil nil nil nil [22273 22302]) ("flyspell-minibuffer-p" function nil ("buffer") nil "Is BUFFER a minibuffer?" nil [22527 22694]) ("flyspell-version" function nil nil ((user-visible . t)) "The flyspell version" nil [22933 23010]) ("flyspell-accept-buffer-local-defs" function nil nil nil (let ((buf (current-buffer))) (ispell-accept-buffer-local-defs) (set-buffer buf)) nil [23234 24198]) ("flyspell-mode-on" function nil nil nil "Turn Flyspell mode on.  Do not use this; use `flyspell-mode' instead." nil [24422 27123]) ("flyspell-delay-commands" function nil nil nil "Install the standard set of Flyspell delayed commands." nil [27347 27570]) ("flyspell-delay-command" function nil ("command") ((user-visible . t)) "Set COMMAND to be delayed, for Flyspell.
When flyspell `post-command-hook' is invoked because a delayed command
as been used the current word is not immediately checked.
It will be checked only after `flyspell-delay' seconds." nil [27794 28150]) ("flyspell-deplacement-commands" function nil nil nil "Install the standard set of Flyspell deplacement commands." nil [28374 28627]) ("flyspell-deplacement-command" function nil ("command") ((user-visible . t)) "Set COMMAND that implement cursor movements, for Flyspell.
When flyspell `post-command-hook' is invoked because of a deplacement command
as been used the current word is checked only if the previous command was
not the very same deplacement command." nil [28851 29247]) ("flyspell-ignore-commands" function nil nil nil "Install the standard set of Flyspell ignored commands." nil [29471 29697]) ("flyspell-ignore-command" function nil ("command") ((user-visible . t)) "Set COMMAND to be ignored, for Flyspell.
When flyspell `post-command-hook' is invoked because of an
ignored command having been used, the changes in the text made by
that command are ignored.  This feature is meant for commands that
change text in a way that does not affect individual words, such
as `fill-paragraph'." nil [29921 30389]) ("flyspell-word-cache-start" variable nil nil nil nil nil [30613 30652]) ("flyspell-word-cache-end" variable nil nil nil nil nil [30653 30692]) ("flyspell-word-cache-word" variable nil nil nil nil nil [30693 30732]) ("flyspell-word-cache-result" variable nil (quote _) nil nil nil [30733 30771]) ("make-variable-buffer-local" code nil [30772 30827]) ("make-variable-buffer-local" code nil [30828 30881]) ("make-variable-buffer-local" code nil [30882 30936]) ("make-variable-buffer-local" code nil [30937 30993]) ("flyspell-pre-buffer" variable nil nil nil nil nil [31365 31401]) ("flyspell-pre-point" variable nil nil nil nil nil [31402 31438]) ("flyspell-pre-column" variable nil nil nil nil nil [31439 31475]) ("flyspell-pre-pre-buffer" variable nil nil nil nil nil [31476 31512]) ("flyspell-pre-pre-point" variable nil nil nil nil nil [31513 31549]) ("flyspell-previous-command" variable nil nil nil "The last interactive command checked by Flyspell." nil [31773 31865]) ("flyspell-pre-command-hook" function nil nil ((user-visible . t)) "Save the current buffer and point for Flyspell's post-command hook." nil [32089 32342]) ("flyspell-mode-off" function nil nil nil "Turn Flyspell mode off." nil [32581 33157]) ("flyspell-check-pre-word-p" function nil nil nil "Return non-nil if we should check the word before point.
More precisely, it applies to the word that was before point
before the current command." nil [33381 34641]) ("flyspell-changes" variable nil nil nil nil nil [35013 35042]) ("flyspell-after-change-function" function nil ("start" "stop" "len") ((user-visible . t)) "Save the current buffer and point for Flyspell's post-command hook." nil [35266 35556]) ("flyspell-check-changed-word-p" function nil ("start" "stop") nil "Return t when the changed word has to be checked.
The answer depends of several criteria.
Mostly we check word delimiters." nil [35780 36264]) ("flyspell-check-word-p" function nil nil nil "Return t when the word at `point' has to be checked.
The answer depends of several criteria.
Mostly we check word delimiters." nil [36488 37510]) ("flyspell-debug-signal-no-check" function nil ("msg" "obj") nil (setq debug-on-error t) nil [37734 38011]) ("flyspell-debug-signal-pre-word-checked" function nil nil nil (setq debug-on-error t) nil [38236 38748]) ("flyspell-debug-signal-word-checked" function nil nil nil (setq debug-on-error t) nil [38977 41012]) ("flyspell-debug-signal-changed-checked" function nil nil nil (setq debug-on-error t) nil [41237 41548]) ("flyspell-post-command-hook" function nil nil ((user-visible . t)) "The `post-command-hook' used by flyspell to check a word in-the-fly." nil [42586 44204]) ("flyspell-notify-misspell" function nil ("start" "end" "word" "poss") nil (let ((replacements (if (stringp poss) poss (if flyspell-sort-corrections (sort (car (cdr (cdr poss))) (quote string<)) (car (cdr (cdr poss))))))) (if flyspell-issue-message-flag (message (format "mispelling `%s'  %S" word replacements)))) nil [44428 44742]) ("flyspell-word-search-backward" function nil ("word" "bound") nil (save-excursion (let ((r (quote nil)) p) (while (and (not r) (setq p (search-backward word bound t))) (let ((lw (flyspell-get-word (quote nil)))) (if (and (consp lw) (string-equal (car lw) word)) (setq r p) (goto-char p)))) r)) nil [44966 45265]) ("flyspell-word-search-forward" function nil ("word" "bound") nil (save-excursion (let ((r (quote nil)) p) (while (and (not r) (setq p (search-forward word bound t))) (let ((lw (flyspell-get-word (quote nil)))) (if (and (consp lw) (string-equal (car lw) word)) (setq r p) (goto-char (1+ p))))) r)) nil [45492 45794]) ("flyspell-word" function nil ("&optional" "following") ((user-visible . t)) "Spell check a word." nil [46021 50618]) ("flyspell-math-tex-command-p" function nil nil nil (when (fboundp (quote texmathp)) (if flyspell-check-tex-math-command nil (condition-case nil (texmathp) (error nil)))) nil [53345 53519]) ("flyspell-tex-command-p" function nil ("word") nil "Return t if WORD is a TeX command." nil [53743 54103]) ("flyspell-casechars-cache" variable nil nil nil nil nil [54327 54364]) ("flyspell-ispell-casechars-cache" variable nil nil nil nil nil [54365 54409]) ("make-variable-buffer-local" code nil [54410 54464]) ("make-variable-buffer-local" code nil [54465 54526]) ("flyspell-get-casechars" function nil nil nil "This function builds a string that is the regexp of word chars.
In order to avoid one useless string construction,
this function changes the last char of the `ispell-casechars' string." nil [54750 55461]) ("flyspell-not-casechars-cache" variable nil nil nil nil nil [55686 55727]) ("flyspell-ispell-not-casechars-cache" variable nil nil nil nil nil [55728 55776]) ("make-variable-buffer-local" code nil [55777 55835]) ("make-variable-buffer-local" code nil [55836 55901]) ("flyspell-get-not-casechars" function nil nil nil "This function builds a string that is the regexp of non-word chars." nil [56125 56775]) ("flyspell-get-word" function nil ("following" "&optional" "extra-otherchars") nil "Return the word for spell-checking according to Ispell syntax.
If optional argument FOLLOWING is non-nil or if `flyspell-following-word'
is non-nil when called interactively, then the following word
(rather than preceding) is checked when the cursor is not over a word.
Optional second argument contains otherchars that can be included in word
many times.

Word syntax described by `flyspell-dictionary-alist' (which see)." nil [56999 59297]) ("flyspell-get-word\\.old" function nil ("following") nil "Return the word for spell-checking according to Ispell syntax.
If argument FOLLOWING is non-nil or if `ispell-following-word'
is non-nil when called interactively, then the following word
(rather than preceding) is checked when the cursor is not over a word.
Optional second argument contains other chars that can be included in word
many times.

Word syntax described by `ispell-dictionary-alist' (which see)." nil [59299 61288]) ("flyspell-small-region" function nil ("beg" "end") nil "Flyspell text between BEG and END." nil [61512 62239]) ("flyspell-external-ispell-process" variable nil (quote nil) nil "The external Flyspell Ispell process." nil [62463 62550]) ("flyspell-external-ispell-buffer" variable nil (quote nil) nil nil nil [62774 62818]) ("flyspell-large-region-buffer" variable nil (quote nil) nil nil nil [62819 62860]) ("flyspell-large-region-beg" variable nil (point-min) nil nil nil [62861 62907]) ("flyspell-large-region-end" variable nil (point-max) nil nil nil [62908 62954]) ("flyspell-external-point-words" function nil nil nil (let ((buffer flyspell-external-ispell-buffer)) (set-buffer buffer) (beginning-of-buffer) (let ((size (- flyspell-large-region-end flyspell-large-region-beg)) (start flyspell-large-region-beg) (pword "") (pcount 1)) (while (< (point) (- (point-max) 1)) (if (re-search-forward "\\([^
]+\\)
" (point-max) t) (let ((word (match-string 1))) (if (string= word pword) (setq pcount (1+ pcount)) (progn (setq pword word) (setq pcount 1))) (goto-char (match-end 0)) (if flyspell-issue-message-flag (message "Spell Checking...%d%% [%s]" (* 100 (/ (float (point)) (point-max))) word)) (set-buffer flyspell-large-region-buffer) (goto-char flyspell-large-region-beg) (let ((keep t) (n 0)) (while (and (or (< n pcount) keep) (search-forward word flyspell-large-region-end t)) (progn (goto-char (- (point) 1)) (setq n (1+ n)) (setq keep (flyspell-word)))) (if (= n pcount) (setq flyspell-large-region-beg (point)))) (set-buffer buffer)) (goto-char (point-max))))) (if flyspell-issue-message-flag (message "Spell Checking completed.")) (kill-buffer flyspell-external-ispell-buffer) (setq flyspell-external-ispell-buffer nil)) nil [63178 64764]) ("flyspell-process-localwords" function nil nil nil "Parse Localwords in the buffer and remove them from the mispellings
buffer before flyspell attempts to check them." nil [65212 66673]) ("flyspell-large-region" function nil ("beg" "end") nil (let* ((curbuf (current-buffer)) (buffer (get-buffer-create "*flyspell-region*"))) (setq flyspell-external-ispell-buffer buffer) (setq flyspell-large-region-buffer curbuf) (setq flyspell-large-region-beg beg) (setq flyspell-large-region-end end) (set-buffer buffer) (erase-buffer) (if flyspell-issue-message-flag (message "Checking region...")) (set-buffer curbuf) (let ((c (apply (quote call-process-region) beg end ispell-program-name nil buffer nil (if (boundp (quote ispell-list-command)) ispell-list-command "-l") (let (args) (if ispell-local-dictionary (setq ispell-dictionary ispell-local-dictionary)) (setq args (ispell-get-ispell-args)) (if ispell-dictionary (setq args (append (list "-d" ispell-dictionary) args))) (if ispell-personal-dictionary (setq args (append args (list "-p" (expand-file-name ispell-personal-dictionary))))) (setq args (append args ispell-extra-args)) args)))) (if (= c 0) (progn (flyspell-process-localwords) (with-current-buffer curbuf (flyspell-delete-region-overlays beg end)) (flyspell-external-point-words)) (error "Can't check region...")))) nil [66897 68402]) ("flyspell-region" function nil ("beg" "end") ((user-visible . t)) "Flyspell text between BEG and END." nil [69085 69455]) ("flyspell-buffer" function nil nil ((user-visible . t)) "Flyspell whole buffer." nil [69694 69807]) ("flyspell-old-buffer-error" variable nil nil nil nil nil [70031 70069]) ("flyspell-old-pos-error" variable nil nil nil nil nil [70070 70105]) ("flyspell-goto-next-error" function nil nil ((user-visible . t)) "Go to the next previously detected error.
In general FLYSPELL-GOTO-NEXT-ERROR must be used after
FLYSPELL-BUFFER." nil [70329 71354]) ("flyspell-overlay-p" function nil ("o") nil "A predicate that return true iff O is an overlay used by flyspell." nil [71578 71734]) ("flyspell-delete-region-overlays" function nil ("beg" "end") nil "Delete overlays used by flyspell in a given region." nil [71958 72239]) ("flyspell-delete-all-overlays" function nil nil nil "Delete all the overlays used by flyspell." nil [72611 72756]) ("flyspell-unhighlight-at" function nil ("pos") nil "Remove the flyspell overlay that are located at POS." nil [72980 73379]) ("flyspell-properties-at-p" function nil ("pos") nil "Return t if there is a text property at POS, not counting `local-map'.
If variable `flyspell-highlight-properties' is set to nil,
text with properties are not checked.  This function is used to discover
if the character at POS has any other property." nil [73751 74261]) ("make-flyspell-overlay" function nil ("beg" "end" "face" "mouse-face") nil "Allocate an overlay to highlight an incorrect word.
BEG and END specify the range in the buffer of that word.
FACE and MOUSE-FACE specify the `face' and `mouse-face' properties
for the overlay." nil [74485 75678]) ("flyspell-highlight-incorrect-region" function nil ("beg" "end" "poss") nil "Set up an overlay on a misspelled word, in the buffer from BEG to END." nil [75902 77123]) ("flyspell-highlight-duplicate-region" function nil ("beg" "end") nil "Set up an overlay on a duplicated word, in the buffer from BEG to END." nil [77347 78081]) ("flyspell-auto-correct-pos" variable nil nil nil nil nil [78305 78343]) ("flyspell-auto-correct-region" variable nil nil nil nil nil [78344 78385]) ("flyspell-auto-correct-ring" variable nil nil nil nil nil [78386 78425]) ("flyspell-auto-correct-word" variable nil nil nil nil nil [78426 78465]) ("make-variable-buffer-local" code nil [78466 78521]) ("make-variable-buffer-local" code nil [78522 78580]) ("make-variable-buffer-local" code nil [78581 78637]) ("make-variable-buffer-local" code nil [78638 78694]) ("flyspell-check-previous-highlighted-word" function nil ("&optional" "arg") ((user-visible . t)) "Correct the closer misspelled word.
This function scans a mis-spelled word before the cursor. If it finds one
it proposes replacement for that word. With prefix arg, count that many
misspelled words backwards." nil [78918 79806]) ("flyspell-display-next-corrections" function nil ("corrections") nil (let ((string "Corrections:") (l corrections) (pos (quote nil))) (while (< (length string) 80) (if (equal (car l) flyspell-auto-correct-word) (setq pos (cons (+ 1 (length string)) pos))) (setq string (concat string " " (car l))) (setq l (cdr l))) (while (consp pos) (let ((num (car pos))) (put-text-property num (+ num (length flyspell-auto-correct-word)) (quote face) (quote flyspell-incorrect-face) string)) (setq pos (cdr pos))) (if (fboundp (quote display-message)) (display-message (quote no-log) string) (message string))) nil [80030 80659]) ("flyspell-abbrev-table" function nil nil nil (if flyspell-use-global-abbrev-table-p global-abbrev-table local-abbrev-table) nil [80883 81006]) ("flyspell-define-abbrev" function nil ("name" "expansion") nil (let ((table (flyspell-abbrev-table))) (when table (define-abbrev table name expansion))) nil [81230 81379]) ("flyspell-auto-correct-word" function nil nil ((user-visible . t)) "Correct the current word.
This command proposes various successive corrections for the current word." nil [81603 85244]) ("flyspell-auto-correct-previous-pos" variable nil nil nil "Holds the start of the first incorrect word before point." nil [85468 85577]) ("flyspell-auto-correct-previous-hook" function nil nil ((user-visible . t)) "Hook to track successive calls to `flyspell-auto-correct-previous-word'.
Sets flyspell-auto-correct-previous-pos to nil" nil [85801 86198]) ("flyspell-auto-correct-previous-word" function nil ("position") ((user-visible . t)) "*Auto correct the first mispelled word that occurs before point." nil [86422 87895]) ("flyspell-correct-word" function nil ("event") ((user-visible . t)) "Pop up a menu of possible corrections for a misspelled word.
The word checked is the word at the mouse position." nil [88119 91010]) ("flyspell-xemacs-correct" function nil ("replace" "poss" "word" "cursor-location" "start" "end" "save") nil "The xemacs popup menu callback." nil [91234 92434]) ("flyspell-ajust-cursor-point" function nil ("save" "cursor-location" "old-max") nil (if (>= save cursor-location) (let ((new-pos (+ save (- (point-max) old-max)))) (goto-char (cond ((< new-pos (point-min)) (point-min)) ((> new-pos (point-max)) (point-max)) (t new-pos)))) (goto-char save)) nil [92658 92975]) ("flyspell-emacs-popup" function nil ("event" "poss" "word") nil "The Emacs popup menu." nil [93199 94510]) ("flyspell-xemacs-popup" function nil ("event" "poss" "word" "cursor-location" "start" "end" "save") nil "The XEmacs popup menu." nil [94734 96448]) ("flyspell-maybe-correct-transposition" function nil ("beg" "end" "poss") nil "Check replacements for transposed characters.

If the text between BEG and END is equal to a correction suggested by
Ispell, after transposing two adjacent characters, correct the text,
and return t.

The third arg POSS is either the symbol 'doublon' or a list of
possible corrections as returned by 'ispell-parse-output'.

This function is meant to be added to 'flyspell-incorrect-hook'." nil [96672 97454]) ("flyspell-maybe-correct-doubling" function nil ("beg" "end" "poss") nil "Check replacements for doubled characters.

If the text between BEG and END is equal to a correction suggested by
Ispell, after removing a pair of doubled characters, correct the text,
and return t.

The third arg POSS is either the symbol 'doublon' or a list of
possible corrections as returned by 'ispell-parse-output'.

This function is meant to be added to 'flyspell-incorrect-hook'." nil [97456 98473]) ("flyspell-already-abbrevp" function nil ("table" "word") nil (let ((sym (abbrev-symbol word table))) (and sym (symbolp sym))) nil [98697 98813]) ("flyspell-change-abbrev" function nil ("table" "old" "new") nil (set (abbrev-symbol old table) new) nil [99037 99121]) ("flyspell-auto-correct-previous-word" function nil ("around" "easymacs-flyspell-auto-correct") nil "Correct current word if misspelled, else previous
    misspelling.  Protect against accidentally changing a word
    that cannot be seen, because it is somewhere off the screen." nil [99345 99927]) ("ad-activate" code nil [99929 99979]) ("flyspell" package nil nil nil [99981 100000]))
    :unmatched-syntax 'nil
    )
    (semanticdb-table "dot.emacs"
    :file "dot.emacs"
    :pointmax 2365
    :major-mode 'emacs-lisp-mode
    :tokens '(("emacs-root" variable nil "~/" nil "My home directory --- the root of my personal emacs load-path." nil [83 174]) ("add-to-list" code nil [176 229]) ("add-to-list" code nil [230 282]) ("labels" code nil [347 791]) ("aquamacs-p" variable nil (string-match "Aquamacs" (version)) nil nil nil [793 848]) ("load-library" code nil [850 872]) ("load-library" code nil [910 933]) ("load-library" code nil [984 1009]) ("if" code nil [1044 1085]) ("load-library" code nil [1111 1137]) ("color-theme" include nil nil nil [1172 1194]) ("eval-after-load" code nil [1195 1353]))
    :unmatched-syntax 'nil
    )
   (semanticdb-table "efuncs.el"
    :file "efuncs.el"
    :pointmax 2985
    :major-mode 'emacs-lisp-mode
    :tokens '(("global-unset-key" code nil [44 130]) ("global-set-key" code nil [132 170]) ("global-set-key" code nil [171 207]) ("global-set-key" code nil [208 274]) ("insert-date" function nil nil ((user-visible . t)) "Insert date at point." nil [305 426]) ("fset" code nil [488 697]) ("mark-buffer-and-copy" function nil nil ((user-visible . t)) "Mark the entire buffer and put it in the kill ring" nil [896 1043]) ("global-set-key" code nil [1045 1091]) ("count-words-region" function nil ("beginning" "end") ((user-visible . t)) "Print number of words in the region." nil [1137 1755]) ("count-words-buffer" function nil nil ((user-visible . t)) "Count all the words in the buffer" nil [1799 1931]) ("global-set-key" code nil [1977 2025]) ("rename-file-and-buffer" function nil nil ((user-visible . t)) "Renames current buffer and file it is visiting." nil [2120 2779]) ("global-set-key" code nil [2781 2835]) ("global-set-key" code nil [2837 2879]))
    :unmatched-syntax 'nil
    )
   (semanticdb-table "blogging.el"
    :file "blogging.el"
    :pointmax 2145
    :major-mode 'emacs-lisp-mode
    :tokens 'nil
    )
   (semanticdb-table "my-config.el"
    :file "my-config.el"
    :pointmax 937
    :major-mode 'emacs-lisp-mode
    :tokens '(("setq" code nil [31 58]) ("transient-mark-mode" code nil [79 102]) ("tool-bar-mode" code nil [127 146]) ("server-start" code nil [187 201]) ("setq" code nil [252 285]) ("display-time" code nil [297 311]) ("setq" code nil [317 338]) ("setq" code nil [415 455]) ("setq" code nil [456 487]) ("setq" code nil [520 540]) ("setq" code nil [553 603]) ("setq" code nil [605 673]) ("setq" code nil [675 705]) ("setq" code nil [709 743]) ("setq" code nil [781 840]) ("global-set-key" code nil [841 876]) ("smooth-scrolling" include nil nil nil [878 905]) ("setq" code nil [906 935]))
    :unmatched-syntax 'nil
    )
   (semanticdb-table "modes.el"
    :file "modes.el"
    :pointmax 4294
    :major-mode 'emacs-lisp-mode
    :tokens '(("setq-default" code nil [47 76]) ("setq" code nil [77 113]) ("setq" code nil [114 248]) ("setq" code nil [259 391]) ("setq" code nil [393 527]) ("add-to-list" code nil [567 621]) ("define-key" code nil [622 669]) ("define-key" code nil [670 713]) ("setq" code nil [714 735]) ("add-hook" code nil [736 820]) ("html-mode" function nil nil ((use-visible . t) (prototype . t)) "Yay SGML" nil [832 878]) ("add-to-list" code nil [879 934]) ("add-to-list" code nil [935 991]) ("add-to-list" code nil [992 1046]) ("add-to-list" code nil [1047 1102]) ("setq" code nil [1103 1241]) ("yaml-mode" include nil nil nil [1252 1272]) ("add-to-list" code nil [1273 1328]) ("add-hook" code nil [1329 1433]) ("js2-mode" function nil nil ((use-visible . t) (prototype . t)) nil nil [1573 1605]) ("add-to-list" code nil [1606 1658]) ("krl-mode" include nil nil nil [1668 1687]) ("add-to-list" code nil [1688 1741]) ("puppet-mode" function nil nil ((use-visible . t) (prototype . t)) "Puppet mode" nil [1754 1807]) ("add-to-list" code nil [1808 1863]) ("wikipedia-mode" function nil nil ((use-visible . t) (prototype . t)) "Major mode for editing documents in Wikipedia markup." nil [1879 1983]) ("add-to-list" code nil [1984 2047]) ("add-to-list" code nil [2048 2130]) ("wikipedia-mode" function nil nil ((prototype . t)) nil nil [2143 2181]) ("setq" code nil [2199 2238]) ("setq" code nil [2239 2444]) ("setq" code nil [2445 2529]) ("ruby-mode" function nil nil ((use-visible . t) (prototype . t)) "Ruby editing mode." nil [2547 2603]) ("add-to-list" code nil [2604 2657]) ("add-to-list" code nil [2658 2717]) ("add-hook" code nil [2777 2822]) ("add-hook" code nil [2823 2869]) ("run-ruby" function nil nil ((prototype . t)) "Run an inferior Ruby process" nil [2871 2935]) ("inf-ruby-keys" function nil nil ((prototype . t)) "Set local key defs for inf-ruby in ruby-mode" nil [2936 3021]) ("add-hook" code nil [3022 3134]) ("rails" include nil nil nil [3140 3156]) ("ruby-electric" include nil nil nil [3157 3181]) ("speedbar-frame-mode" function nil nil ((use-visible . t) (prototype . t)) "Popup a speedbar frame" nil [3200 3269]) ("speedbar-get-focus" function nil nil ((use-visible . t) (prototype . t)) "Jump to speedbar frame" nil [3270 3338]) ("add-hook" code nil [3369 3432]) ("add-hook" code nil [3460 3517]) ("setq" code nil [3532 3573]) ("semantic-load" include nil nil nil [3574 3598]) ("ecb" include nil nil nil [3608 3622]) ("ido" include nil nil nil [3632 3646]) ("ido-mode" code nil [3647 3659]) ("setq" code nil [3660 3693]) ("setq" code nil [3775 3815]) ("setq" code nil [3859 3912]) ("flyspell-mode" function nil nil ((use-visible . t) (prototype . t)) "On-the-fly spelling checker." nil [3927 3996]) ("predictive" include nil nil nil [4071 4092]) ("predictive-html" include nil nil nil [4093 4119]) ("php-mode" include nil nil nil [4130 4149]) ("setq" code nil [4150 4275]) ("git" include nil nil nil [4277 4291]))
    :unmatched-syntax 'nil
    )
   )
  )
